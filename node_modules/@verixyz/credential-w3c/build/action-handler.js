"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialIssuer = void 0;
const did_jwt_vc_1 = require("did-jwt-vc");
const did_jwt_1 = require("did-jwt");
const _1 = require("./");
const debug_1 = __importDefault(require("debug"));
const utils_1 = require("@verixyz/utils");
const debug = (0, debug_1.default)('verixyz:w3c:action-handler');
/**
 * A verixyz plugin that implements the {@link ICredentialIssuer} methods.
 *
 * @public
 */
class CredentialIssuer {
    constructor() {
        this.schema = _1.schema.ICredentialIssuer;
        this.methods = {
            createVerifiablePresentation: this.createVerifiablePresentation.bind(this),
            createVerifiableCredential: this.createVerifiableCredential.bind(this),
            verifyCredential: this.verifyCredential.bind(this),
            verifyPresentation: this.verifyPresentation.bind(this),
        };
    }
    /** {@inheritdoc ICredentialIssuer.createVerifiablePresentation} */
    createVerifiablePresentation(args, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const presentationContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.presentation) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const presentationType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.presentation) === null || _b === void 0 ? void 0 : _b.type, 'VerifiablePresentation');
            const presentation = Object.assign(Object.assign({}, args === null || args === void 0 ? void 0 : args.presentation), { '@context': presentationContext, type: presentationType, issuanceDate: ((_c = args === null || args === void 0 ? void 0 : args.presentation) === null || _c === void 0 ? void 0 : _c.issuanceDate) || new Date() });
            if (!(0, utils_1.isDefined)(presentation.holder)) {
                throw new Error('invalid_argument: args.presentation.holder must not be empty');
            }
            if (args.presentation.verifiableCredential) {
                const credentials = args.presentation.verifiableCredential.map((cred) => {
                    // map JWT credentials to their canonical form
                    if (typeof cred !== 'string' && cred.proof.jwt) {
                        return cred.proof.jwt;
                    }
                    else {
                        return cred;
                    }
                });
                presentation.verifiableCredential = credentials;
            }
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: presentation.holder });
            }
            catch (e) {
                throw new Error('invalid_argument: args.presentation.holder must be a DID managed by this agent');
            }
            try {
                //FIXME: `args` should allow picking a key or key type
                const key = identifier.keys.find((k) => k.type === 'Secp256k1' || k.type === 'Ed25519');
                if (!key)
                    throw Error('No signing key for ' + identifier.did);
                let verifiablePresentation;
                if (args.proofFormat === 'lds') {
                    if (typeof context.agent.createVerifiablePresentationLD === 'function') {
                        verifiablePresentation = yield context.agent.createVerifiablePresentationLD(args);
                    }
                    else {
                        throw new Error('invalid_configuration: your agent does not seem to have ICredentialIssuerLD plugin installed');
                    }
                }
                else {
                    // only add issuanceDate for JWT
                    presentation.issuanceDate = args.presentation.issuanceDate || new Date().toISOString();
                    debug('Signing VP with', identifier.did);
                    let alg = 'ES256K';
                    if (key.type === 'Ed25519') {
                        alg = 'EdDSA';
                    }
                    const signer = wrapSigner(context, key, alg);
                    const jwt = yield (0, did_jwt_vc_1.createVerifiablePresentationJwt)(presentation, { did: identifier.did, signer, alg }, { removeOriginalFields: args.removeOriginalFields });
                    //FIXME: flagging this as a potential privacy leak.
                    debug(jwt);
                    verifiablePresentation = (0, did_jwt_vc_1.normalizePresentation)(jwt);
                }
                if (args.save) {
                    yield context.agent.dataStoreSaveVerifiablePresentation({ verifiablePresentation });
                }
                return verifiablePresentation;
            }
            catch (error) {
                debug(error);
                return Promise.reject(error);
            }
        });
    }
    /** {@inheritdoc ICredentialIssuer.createVerifiableCredential} */
    createVerifiableCredential(args, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const credentialContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.credential) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const credentialType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.credential) === null || _b === void 0 ? void 0 : _b.type, 'VerifiableCredential');
            const credential = Object.assign(Object.assign({}, args === null || args === void 0 ? void 0 : args.credential), { '@context': credentialContext, type: credentialType, issuanceDate: ((_c = args === null || args === void 0 ? void 0 : args.credential) === null || _c === void 0 ? void 0 : _c.issuanceDate) || new Date().toISOString() });
            //FIXME: if the identifier is not found, the error message should reflect that.
            const issuer = (0, utils_1.extractIssuer)(credential);
            if (!issuer || typeof issuer === 'undefined') {
                throw new Error('invalid_argument: args.credential.issuer must not be empty');
            }
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: issuer });
            }
            catch (e) {
                throw new Error(`invalid_argument: args.credential.issuer must be a DID managed by this agent. ${e}`);
            }
            try {
                //FIXME: `args` should allow picking a key or key type
                const key = identifier.keys.find((k) => k.type === 'Secp256k1' || k.type === 'Ed25519');
                if (!key)
                    throw Error('No signing key for ' + identifier.did);
                let verifiableCredential;
                if (args.proofFormat === 'lds') {
                    if (typeof context.agent.createVerifiableCredentialLD === 'function') {
                        verifiableCredential = yield context.agent.createVerifiableCredentialLD(args);
                    }
                    else {
                        throw new Error('invalid_configuration: your agent does not seem to have ICredentialIssuerLD plugin installed');
                    }
                }
                else {
                    debug('Signing VC with', identifier.did);
                    let alg = 'ES256K';
                    if (key.type === 'Ed25519') {
                        alg = 'EdDSA';
                    }
                    const signer = wrapSigner(context, key, alg);
                    const jwt = yield (0, did_jwt_vc_1.createVerifiableCredentialJwt)(credential, { did: identifier.did, signer, alg }, { removeOriginalFields: args.removeOriginalFields });
                    //FIXME: flagging this as a potential privacy leak.
                    debug(jwt);
                    verifiableCredential = (0, did_jwt_vc_1.normalizeCredential)(jwt);
                }
                if (args.save) {
                    yield context.agent.dataStoreSaveVerifiableCredential({ verifiableCredential });
                }
                return verifiableCredential;
            }
            catch (error) {
                debug(error);
                return Promise.reject(error);
            }
        });
    }
    /** {@inheritdoc ICredentialIssuer.verifyCredential} */
    verifyCredential(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const credential = args.credential;
            if (typeof credential === 'string' || ((_a = credential === null || credential === void 0 ? void 0 : credential.proof) === null || _a === void 0 ? void 0 : _a.jwt)) {
                // JWT
                let jwt;
                if (typeof credential === 'string') {
                    jwt = credential;
                }
                else {
                    jwt = credential.proof.jwt;
                }
                const resolver = { resolve: (didUrl) => context.agent.resolveDid({ didUrl }) };
                try {
                    const verification = yield (0, did_jwt_vc_1.verifyCredential)(jwt, resolver);
                    return true;
                }
                catch (e) {
                    //TODO: return a more detailed reason for failure
                    return false;
                }
            }
            else {
                // JSON-LD
                if (typeof context.agent.verifyCredentialLD === 'function') {
                    const result = yield context.agent.verifyCredentialLD(args);
                    return result;
                }
                else {
                    throw new Error('invalid_configuration: your agent does not seem to have ICredentialIssuerLD plugin installed');
                }
            }
        });
    }
    /** {@inheritdoc ICredentialIssuer.verifyPresentation} */
    verifyPresentation(args, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const presentation = args.presentation;
            if (typeof presentation === 'string' || ((_a = presentation === null || presentation === void 0 ? void 0 : presentation.proof) === null || _a === void 0 ? void 0 : _a.jwt)) {
                // JWT
                let jwt;
                if (typeof presentation === 'string') {
                    jwt = presentation;
                }
                else {
                    jwt = presentation.proof.jwt;
                }
                const resolver = { resolve: (didUrl) => context.agent.resolveDid({ didUrl }) };
                let audience = args.domain;
                if (!audience) {
                    const { payload } = yield (0, did_jwt_1.decodeJWT)(jwt);
                    if (payload.aud) {
                        // automatically add a managed DID as audience if one is found
                        const intendedAudience = (0, utils_1.asArray)(payload.aud);
                        const managedDids = yield context.agent.didManagerFind();
                        const filtered = managedDids.filter((identifier) => intendedAudience.includes(identifier.did));
                        if (filtered.length > 0) {
                            audience = filtered[0].did;
                        }
                    }
                }
                try {
                    const verification = yield (0, did_jwt_vc_1.verifyPresentation)(jwt, resolver, {
                        challenge: args.challenge,
                        domain: args.domain,
                        audience,
                    });
                    return true;
                }
                catch (e) {
                    //TODO: return a more detailed reason for failure
                    return false;
                }
            }
            else {
                // JSON-LD
                if (typeof context.agent.verifyPresentationLD === 'function') {
                    const result = yield context.agent.verifyPresentationLD(args);
                    return result;
                }
                else {
                    throw new Error('invalid_configuration: your agent does not seem to have ICredentialIssuerLD plugin installed');
                }
            }
        });
    }
}
exports.CredentialIssuer = CredentialIssuer;
function wrapSigner(context, key, algorithm) {
    return (data) => __awaiter(this, void 0, void 0, function* () {
        const result = yield context.agent.keyManagerSign({ keyRef: key.kid, data: data, algorithm });
        return result;
    });
}
//# sourceMappingURL=action-handler.js.map