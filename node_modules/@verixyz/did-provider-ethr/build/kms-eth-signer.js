"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KmsEthereumSigner = void 0;
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const address_1 = require("@ethersproject/address");
const properties_1 = require("@ethersproject/properties");
const transactions_1 = require("@ethersproject/transactions");
/**
 * Creates an `@ethersproject/abstract-signer` implementation by wrapping
 * a verixyz agent with a key-manager that should be capable of `eth_signTransaction`
 */
class KmsEthereumSigner extends abstract_signer_1.Signer {
    constructor(controllerKey, context, provider) {
        super();
        this.controllerKey = controllerKey;
        this.context = context;
        this.provider = provider;
    }
    getAddress() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // publicKeyHex is not available when using web3provider
            if ((_a = this.controllerKey.meta) === null || _a === void 0 ? void 0 : _a.account) {
                return (_b = this.controllerKey.meta) === null || _b === void 0 ? void 0 : _b.account;
            }
            return (0, transactions_1.computeAddress)('0x' + this.controllerKey.publicKeyHex);
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield (0, properties_1.resolveProperties)(transaction);
            if (tx.from != null) {
                const thisAddress = yield this.getAddress();
                if ((0, address_1.getAddress)(tx.from) !== thisAddress) {
                    throw new Error(`transaction from address mismatch ${transaction.from} != ${thisAddress}`);
                }
                delete tx.from;
            }
            const signature = yield this.context.agent.keyManagerSign({
                keyRef: this.controllerKey.kid,
                data: (0, transactions_1.serialize)(tx),
                algorithm: 'eth_signTransaction',
                encoding: 'base16',
            });
            return signature;
        });
    }
    signMessage(message) {
        throw new Error('not_implemented: signMessage() Method not implemented by KmsEthereumSigner.');
    }
    connect(provider) {
        return new KmsEthereumSigner(this.controllerKey, this.context, provider);
    }
}
exports.KmsEthereumSigner = KmsEthereumSigner;
//# sourceMappingURL=kms-eth-signer.js.map