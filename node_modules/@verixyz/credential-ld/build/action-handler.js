"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialIssuerLD = void 0;
const _1 = require("./");
const debug_1 = __importDefault(require("debug"));
const ld_context_loader_1 = require("./ld-context-loader");
const utils_1 = require("@verixyz/utils");
const ld_credential_module_1 = require("./ld-credential-module");
const ld_suite_loader_1 = require("./ld-suite-loader");
const debug = (0, debug_1.default)('verixyz:w3c:action-handler');
/**
 * A verixyz plugin that implements the {@link ICredentialIssuerLD} methods.
 *
 * @public
 */
class CredentialIssuerLD {
    constructor(options) {
        this.schema = _1.schema.ICredentialIssuer;
        this.ldCredentialModule = new ld_credential_module_1.LdCredentialModule({
            ldContextLoader: new ld_context_loader_1.LdContextLoader({ contextsPaths: options.contextMaps }),
            ldSuiteLoader: new ld_suite_loader_1.LdSuiteLoader({ verixyzLdSignatures: options.suites }),
        });
        this.methods = {
            createVerifiablePresentationLD: this.createVerifiablePresentationLD.bind(this),
            createVerifiableCredentialLD: this.createVerifiableCredentialLD.bind(this),
            verifyCredentialLD: this.verifyCredentialLD.bind(this),
            verifyPresentationLD: this.verifyPresentationLD.bind(this),
        };
    }
    /** {@inheritdoc ICredentialIssuerLD.createVerifiablePresentationLD} */
    createVerifiablePresentationLD(args, context) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const presentationContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.presentation) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const presentationType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.presentation) === null || _b === void 0 ? void 0 : _b.type, 'VerifiablePresentation');
            const presentation = Object.assign(Object.assign({}, args === null || args === void 0 ? void 0 : args.presentation), { '@context': presentationContext, type: presentationType });
            if (!(0, utils_1.isDefined)(presentation.holder)) {
                throw new Error('invalid_argument: args.presentation.holder must not be empty');
            }
            if (args.presentation.verifiableCredential) {
                const credentials = args.presentation.verifiableCredential.map((cred) => {
                    if (typeof cred !== 'string' && cred.proof.jwt) {
                        return cred.proof.jwt;
                    }
                    else {
                        return cred;
                    }
                });
                presentation.verifiableCredential = credentials;
            }
            //issuanceDate must not be present for presentations because it is not defined in a @context
            delete presentation.issuanceDate;
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: presentation.holder });
            }
            catch (e) {
                throw new Error('invalid_argument: args.presentation.holder must be a DID managed by this agent');
            }
            try {
                const { signingKey, verificationMethodId } = yield this.findSigningKeyWithId(context, identifier, args.keyRef);
                return yield this.ldCredentialModule.signLDVerifiablePresentation(presentation, identifier.did, signingKey, verificationMethodId, args.challenge, args.domain, context);
            }
            catch (error) {
                debug(error);
                return Promise.reject(error);
            }
        });
    }
    /** {@inheritdoc ICredentialIssuerLD.createVerifiableCredentialLD} */
    createVerifiableCredentialLD(args, context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const credentialContext = (0, utils_1.processEntryToArray)((_a = args === null || args === void 0 ? void 0 : args.credential) === null || _a === void 0 ? void 0 : _a['@context'], utils_1.MANDATORY_CREDENTIAL_CONTEXT);
            const credentialType = (0, utils_1.processEntryToArray)((_b = args === null || args === void 0 ? void 0 : args.credential) === null || _b === void 0 ? void 0 : _b.type, 'VerifiableCredential');
            let issuanceDate = ((_c = args === null || args === void 0 ? void 0 : args.credential) === null || _c === void 0 ? void 0 : _c.issuanceDate) || new Date().toISOString();
            if (issuanceDate instanceof Date) {
                issuanceDate = issuanceDate.toISOString();
            }
            const credential = Object.assign(Object.assign({}, args === null || args === void 0 ? void 0 : args.credential), { '@context': credentialContext, type: credentialType, issuanceDate });
            const issuer = (0, utils_1.extractIssuer)(credential);
            if (!issuer || typeof issuer === 'undefined') {
                throw new Error('invalid_argument: args.credential.issuer must not be empty');
            }
            let identifier;
            try {
                identifier = yield context.agent.didManagerGet({ did: issuer });
            }
            catch (e) {
                throw new Error(`invalid_argument: args.credential.issuer must be a DID managed by this agent. ${e}`);
            }
            try {
                const { signingKey, verificationMethodId } = yield this.findSigningKeyWithId(context, identifier, args.keyRef);
                return yield this.ldCredentialModule.issueLDVerifiableCredential(credential, identifier.did, signingKey, verificationMethodId, context);
            }
            catch (error) {
                debug(error);
                return Promise.reject(error);
            }
        });
    }
    /** {@inheritdoc ICredentialIssuerLD.verifyCredentialLD} */
    verifyCredentialLD(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const credential = args.credential;
            return this.ldCredentialModule.verifyCredential(credential, args.fetchRemoteContexts || false, context);
        });
    }
    /** {@inheritdoc ICredentialIssuerLD.verifyPresentationLD} */
    verifyPresentationLD(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const presentation = args.presentation;
            return this.ldCredentialModule.verifyPresentation(presentation, args.challenge, args.domain, args.fetchRemoteContexts || false, context);
        });
    }
    findSigningKeyWithId(context, identifier, keyRef) {
        return __awaiter(this, void 0, void 0, function* () {
            const extendedKeys = yield (0, utils_1.mapIdentifierKeysToDoc)(identifier, 'assertionMethod', context);
            let supportedTypes = this.ldCredentialModule.ldSuiteLoader.getAllSignatureSuiteTypes();
            let signingKey;
            let verificationMethodId;
            if (keyRef) {
                signingKey = extendedKeys.find((k) => k.kid === keyRef);
            }
            if (signingKey && !supportedTypes.includes(signingKey.meta.verificationMethod.type)) {
                debug('WARNING: requested signing key DOES NOT correspond to a supported Signature suite type. Looking for the next best key.');
                signingKey = undefined;
            }
            if (!signingKey) {
                if (keyRef) {
                    debug('WARNING: no signing key was found that matches the reference provided. Searching for the first available signing key.');
                }
                signingKey = extendedKeys.find((k) => supportedTypes.includes(k.meta.verificationMethod.type));
            }
            if (!signingKey)
                throw Error(`key_not_found: No suitable signing key found for ${identifier.did}`);
            verificationMethodId = signingKey.meta.verificationMethod.id;
            return { signingKey, verificationMethodId };
        });
    }
}
exports.CredentialIssuerLD = CredentialIssuerLD;
//# sourceMappingURL=action-handler.js.map