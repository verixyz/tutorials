"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyManager = void 0;
const core_1 = require("@verixyz/core");
const u8a = __importStar(require("uint8arrays"));
const did_jwt_1 = require("did-jwt");
const bytes_1 = require("@ethersproject/bytes");
const transactions_1 = require("@ethersproject/transactions");
const strings_1 = require("@ethersproject/strings");
const ed25519_1 = require("@stablelib/ed25519");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('verixyz:key-manager');
/**
 * Agent plugin that provides {@link @verixyz/core#IKeyManager} methods
 * @public
 */
class KeyManager {
    constructor(options) {
        this.schema = core_1.schema.IKeyManager;
        this.store = options.store;
        this.kms = options.kms;
        this.methods = {
            keyManagerGetKeyManagementSystems: this.keyManagerGetKeyManagementSystems.bind(this),
            keyManagerCreate: this.keyManagerCreate.bind(this),
            keyManagerGet: this.keyManagerGet.bind(this),
            keyManagerDelete: this.keyManagerDelete.bind(this),
            keyManagerImport: this.keyManagerImport.bind(this),
            keyManagerEncryptJWE: this.keyManagerEncryptJWE.bind(this),
            keyManagerDecryptJWE: this.keyManagerDecryptJWE.bind(this),
            keyManagerSignJWT: this.keyManagerSignJWT.bind(this),
            keyManagerSignEthTX: this.keyManagerSignEthTX.bind(this),
            keyManagerSign: this.keyManagerSign.bind(this),
            keyManagerSharedSecret: this.keyManagerSharedSecret.bind(this),
        };
    }
    getKms(name) {
        const kms = this.kms[name];
        if (!kms) {
            throw Error(`invalid_argument: This agent has no registered KeyManagementSystem with name='${name}'`);
        }
        return kms;
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerGetKeyManagementSystems} */
    keyManagerGetKeyManagementSystems() {
        return __awaiter(this, void 0, void 0, function* () {
            return Object.keys(this.kms);
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerCreate} */
    keyManagerCreate(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const kms = this.getKms(args.kms);
            const partialKey = yield kms.createKey({ type: args.type, meta: args.meta });
            const key = Object.assign(Object.assign({}, partialKey), { kms: args.kms });
            if (args.meta || key.meta) {
                key.meta = Object.assign(Object.assign({}, args.meta), key.meta);
            }
            yield this.store.import(key);
            if (key.privateKeyHex) {
                delete key.privateKeyHex;
            }
            return key;
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerGet} */
    keyManagerGet({ kid }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.store.get({ kid });
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerDelete} */
    keyManagerDelete({ kid }) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.store.get({ kid });
            const kms = this.getKms(key.kms);
            yield kms.deleteKey({ kid });
            return this.store.delete({ kid });
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerImport} */
    keyManagerImport(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const kms = this.getKms(key.kms);
            const managedKey = yield kms.importKey(key);
            const { meta } = key;
            const importedKey = Object.assign(Object.assign({}, managedKey), { meta: Object.assign(Object.assign({}, meta), managedKey.meta), kms: key.kms });
            yield this.store.import(importedKey);
            return importedKey;
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerEncryptJWE} */
    keyManagerEncryptJWE({ kid, to, data }) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: if a sender `key` is provided, then it should be used to create an authenticated encrypter
            // const key = await this.store.get({ kid })
            let recipientPublicKey;
            if (to.type === 'Ed25519') {
                recipientPublicKey = (0, bytes_1.arrayify)('0x' + to.publicKeyHex);
                recipientPublicKey = (0, ed25519_1.convertPublicKeyToX25519)(recipientPublicKey);
            }
            else if (to.type === 'X25519') {
                recipientPublicKey = (0, bytes_1.arrayify)('0x' + to.publicKeyHex);
            }
            else {
                throw new Error('not_supported: The recipient public key type is not supported');
            }
            const dataBytes = (0, strings_1.toUtf8Bytes)(data);
            const encrypter = (0, did_jwt_1.createAnonEncrypter)(recipientPublicKey);
            const result = yield (0, did_jwt_1.createJWE)(dataBytes, [encrypter]);
            return JSON.stringify(result);
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerDecryptJWE} */
    keyManagerDecryptJWE({ kid, data }) {
        return __awaiter(this, void 0, void 0, function* () {
            const jwe = JSON.parse(data);
            const ecdh = this.createX25519ECDH(kid);
            // TODO: figure out if the JWE is anon or not to determine the type of decrypter to use
            const decrypter = (0, did_jwt_1.createAnonDecrypter)(ecdh);
            const decrypted = yield (0, did_jwt_1.decryptJWE)(jwe, decrypter);
            const result = (0, strings_1.toUtf8String)(decrypted);
            return result;
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerSignJWT} */
    keyManagerSignJWT({ kid, data }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof data === 'string') {
                return this.keyManagerSign({ keyRef: kid, data, encoding: 'utf-8' });
            }
            else {
                const dataString = u8a.toString(data, 'base16');
                return this.keyManagerSign({ keyRef: kid, data: dataString, encoding: 'base16' });
            }
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerSign} */
    keyManagerSign(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const _a = Object.assign({ encoding: 'utf-8' }, args), { keyRef, data, algorithm, encoding } = _a, extras = __rest(_a, ["keyRef", "data", "algorithm", "encoding"]);
            const keyInfo = yield this.store.get({ kid: keyRef });
            let dataBytes;
            if (typeof data === 'string') {
                if (encoding === 'base16' || encoding === 'hex') {
                    const preData = data.startsWith('0x') ? data.substring(2) : data;
                    dataBytes = u8a.fromString(preData, 'base16');
                }
                else {
                    dataBytes = u8a.fromString(data, encoding);
                }
            }
            else {
                dataBytes = data;
            }
            const kms = this.getKms(keyInfo.kms);
            return kms.sign(Object.assign({ keyRef: keyInfo, algorithm, data: dataBytes }, extras));
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerSignEthTX} */
    keyManagerSignEthTX({ kid, transaction }) {
        return __awaiter(this, void 0, void 0, function* () {
            const _a = transaction, { v, r, s, from } = _a, tx = __rest(_a, ["v", "r", "s", "from"]);
            if (typeof from === 'string') {
                debug('WARNING: executing a transaction signing request with a `from` field.');
                const key = yield this.store.get({ kid });
                if (key.publicKeyHex) {
                    const address = (0, transactions_1.computeAddress)('0x' + key.publicKeyHex);
                    if (address.toLowerCase() !== from.toLowerCase()) {
                        const msg = 'invalid_arguments: keyManagerSignEthTX `from` field does not match the chosen key. `from` field should be omitted.';
                        debug(msg);
                        throw new Error(msg);
                    }
                }
            }
            const data = (0, transactions_1.serialize)(tx);
            const algorithm = 'eth_signTransaction';
            return this.keyManagerSign({ keyRef: kid, data, algorithm, encoding: 'base16' });
        });
    }
    /** {@inheritDoc @verixyz/core#IKeyManager.keyManagerSharedKey} */
    keyManagerSharedSecret(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { secretKeyRef, publicKey } = args;
            const myKeyRef = yield this.store.get({ kid: secretKeyRef });
            const theirKey = publicKey;
            if (myKeyRef.type === theirKey.type ||
                (['Ed25519', 'X25519'].includes(myKeyRef.type) && ['Ed25519', 'X25519'].includes(theirKey.type))) {
                const kms = this.getKms(myKeyRef.kms);
                return kms.sharedSecret({ myKeyRef, theirKey });
            }
            else {
                throw new Error('invalid_argument: the key types have to match to be able to compute a shared secret');
            }
        });
    }
    createX25519ECDH(secretKeyRef) {
        return (theirPublicKey) => __awaiter(this, void 0, void 0, function* () {
            if (theirPublicKey.length !== 32) {
                throw new Error('invalid_argument: incorrect publicKey key length for X25519');
            }
            const publicKey = { type: 'X25519', publicKeyHex: (0, bytes_1.hexlify)(theirPublicKey).substring(2) };
            const shared = yield this.keyManagerSharedSecret({ secretKeyRef, publicKey });
            return (0, bytes_1.arrayify)('0x' + shared);
        });
    }
}
exports.KeyManager = KeyManager;
//# sourceMappingURL=key-manager.js.map