"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCredentialEntity = exports.Credential = void 0;
const typeorm_1 = require("typeorm");
const identifier_1 = require("./identifier");
const message_1 = require("./message");
const presentation_1 = require("./presentation");
const claim_1 = require("./claim");
const utils_1 = require("@verixyz/utils");
let Credential = class Credential extends typeorm_1.BaseEntity {
    set raw(raw) {
        this._raw = raw;
        this.hash = (0, utils_1.computeEntryHash)(raw);
    }
    get raw() {
        return this._raw;
    }
};
__decorate([
    (0, typeorm_1.PrimaryColumn)(),
    __metadata("design:type", String)
], Credential.prototype, "hash", void 0);
__decorate([
    (0, typeorm_1.Column)('simple-json'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], Credential.prototype, "raw", null);
__decorate([
    (0, typeorm_1.ManyToOne)((type) => identifier_1.Identifier, (identifier) => identifier.issuedCredentials, {
        cascade: ['insert'],
        eager: true,
        onDelete: 'CASCADE',
    }),
    __metadata("design:type", identifier_1.Identifier
    // Subject can be null https://w3c.github.io/vc-data-model/#credential-uniquely-identifies-a-subject
    )
], Credential.prototype, "issuer", void 0);
__decorate([
    (0, typeorm_1.ManyToOne)((type) => identifier_1.Identifier, (identifier) => identifier === null || identifier === void 0 ? void 0 : identifier.receivedCredentials, {
        cascade: ['insert'],
        eager: true,
        nullable: true,
    }),
    __metadata("design:type", identifier_1.Identifier)
], Credential.prototype, "subject", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", String)
], Credential.prototype, "id", void 0);
__decorate([
    (0, typeorm_1.Column)(),
    __metadata("design:type", Date)
], Credential.prototype, "issuanceDate", void 0);
__decorate([
    (0, typeorm_1.Column)({ nullable: true }),
    __metadata("design:type", Date)
], Credential.prototype, "expirationDate", void 0);
__decorate([
    (0, typeorm_1.Column)('simple-array'),
    __metadata("design:type", Array)
], Credential.prototype, "context", void 0);
__decorate([
    (0, typeorm_1.Column)('simple-array'),
    __metadata("design:type", Array)
], Credential.prototype, "type", void 0);
__decorate([
    (0, typeorm_1.OneToMany)((type) => claim_1.Claim, (claim) => claim.credential, {
        cascade: ['insert'],
    }),
    __metadata("design:type", Array)
], Credential.prototype, "claims", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)((type) => presentation_1.Presentation, (presentation) => presentation.credentials),
    __metadata("design:type", Array)
], Credential.prototype, "presentations", void 0);
__decorate([
    (0, typeorm_1.ManyToMany)((type) => message_1.Message, (message) => message.credentials),
    __metadata("design:type", Array)
], Credential.prototype, "messages", void 0);
Credential = __decorate([
    (0, typeorm_1.Entity)('credential')
], Credential);
exports.Credential = Credential;
const createCredentialEntity = (vci) => {
    const vc = vci;
    const credential = new Credential();
    credential.context = (0, utils_1.asArray)(vc['@context']);
    credential.type = (0, utils_1.asArray)(vc.type || []);
    credential.id = vc.id;
    if (vc.issuanceDate) {
        credential.issuanceDate = new Date(vc.issuanceDate);
    }
    if (vc.expirationDate) {
        credential.expirationDate = new Date(vc.expirationDate);
    }
    const issuer = new identifier_1.Identifier();
    issuer.did = (0, utils_1.extractIssuer)(vc);
    credential.issuer = issuer;
    if (vc.credentialSubject.id) {
        const subject = new identifier_1.Identifier();
        subject.did = vc.credentialSubject.id;
        credential.subject = subject;
    }
    credential.claims = [];
    for (const type in vc.credentialSubject) {
        if (vc.credentialSubject.hasOwnProperty(type)) {
            const value = vc.credentialSubject[type];
            if (type !== 'id') {
                const isObj = typeof value === 'function' || (typeof value === 'object' && !!value);
                const claim = new claim_1.Claim();
                claim.hash = (0, utils_1.computeEntryHash)(JSON.stringify(vc) + type);
                claim.type = type;
                claim.value = isObj ? JSON.stringify(value) : value;
                claim.isObj = isObj;
                claim.issuer = credential.issuer;
                claim.subject = credential.subject;
                claim.expirationDate = credential.expirationDate;
                claim.issuanceDate = credential.issuanceDate;
                claim.credentialType = credential.type;
                claim.context = credential.context;
                credential.claims.push(claim);
            }
        }
    }
    credential.raw = vci;
    return credential;
};
exports.createCredentialEntity = createCredentialEntity;
//# sourceMappingURL=credential.js.map