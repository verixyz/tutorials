"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreORM = void 0;
const core_1 = require("@verixyz/core");
const message_1 = require("./entities/message");
const claim_1 = require("./entities/claim");
const credential_1 = require("./entities/credential");
const presentation_1 = require("./entities/presentation");
const identifier_1 = require("./entities/identifier");
const typeorm_1 = require("typeorm");
class DataStoreORM {
    constructor(dbConnection) {
        this.schema = core_1.schema.IDataStoreORM;
        this.dbConnection = dbConnection;
        this.methods = {
            dataStoreORMGetIdentifiers: this.dataStoreORMGetIdentifiers.bind(this),
            dataStoreORMGetIdentifiersCount: this.dataStoreORMGetIdentifiersCount.bind(this),
            dataStoreORMGetMessages: this.dataStoreORMGetMessages.bind(this),
            dataStoreORMGetMessagesCount: this.dataStoreORMGetMessagesCount.bind(this),
            dataStoreORMGetVerifiableCredentialsByClaims: this.dataStoreORMGetVerifiableCredentialsByClaims.bind(this),
            dataStoreORMGetVerifiableCredentialsByClaimsCount: this.dataStoreORMGetVerifiableCredentialsByClaimsCount.bind(this),
            dataStoreORMGetVerifiableCredentials: this.dataStoreORMGetVerifiableCredentials.bind(this),
            dataStoreORMGetVerifiableCredentialsCount: this.dataStoreORMGetVerifiableCredentialsCount.bind(this),
            dataStoreORMGetVerifiablePresentations: this.dataStoreORMGetVerifiablePresentations.bind(this),
            dataStoreORMGetVerifiablePresentationsCount: this.dataStoreORMGetVerifiablePresentationsCount.bind(this),
        };
    }
    // Identifiers
    identifiersQuery(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const where = createWhereObject(args);
            let qb = (yield this.dbConnection)
                .getRepository(identifier_1.Identifier)
                .createQueryBuilder('identifier')
                .leftJoinAndSelect('identifier.keys', 'keys')
                .leftJoinAndSelect('identifier.services', 'services')
                .where(where);
            qb = decorateQB(qb, 'message', args);
            return qb;
        });
    }
    dataStoreORMGetIdentifiers(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const identifiers = yield (yield this.identifiersQuery(args, context)).getMany();
            return identifiers.map((i) => {
                const identifier = i;
                if (identifier.controllerKeyId === null) {
                    delete identifier.controllerKeyId;
                }
                if (identifier.alias === null) {
                    delete identifier.alias;
                }
                if (identifier.provider === null) {
                    delete identifier.provider;
                }
                return identifier;
            });
        });
    }
    dataStoreORMGetIdentifiersCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (yield this.identifiersQuery(args, context)).getCount();
        });
    }
    // Messages
    messagesQuery(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const where = createWhereObject(args);
            let qb = (yield this.dbConnection)
                .getRepository(message_1.Message)
                .createQueryBuilder('message')
                .leftJoinAndSelect('message.from', 'from')
                .leftJoinAndSelect('message.to', 'to')
                .leftJoinAndSelect('message.credentials', 'credentials')
                .leftJoinAndSelect('message.presentations', 'presentations')
                .where(where);
            qb = decorateQB(qb, 'message', args);
            if (context.authorizedDID) {
                qb = qb.andWhere(new typeorm_1.Brackets((qb) => {
                    qb.where('message.to = :ident', { ident: context.authorizedDID }).orWhere('message.from = :ident', {
                        ident: context.authorizedDID,
                    });
                }));
            }
            return qb;
        });
    }
    dataStoreORMGetMessages(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = yield (yield this.messagesQuery(args, context)).getMany();
            return messages.map(message_1.createMessage);
        });
    }
    dataStoreORMGetMessagesCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.messagesQuery(args, context)).getCount();
        });
    }
    // Claims
    claimsQuery(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const where = createWhereObject(args);
            let qb = (yield this.dbConnection)
                .getRepository(claim_1.Claim)
                .createQueryBuilder('claim')
                .leftJoinAndSelect('claim.issuer', 'issuer')
                .leftJoinAndSelect('claim.subject', 'subject')
                .where(where);
            qb = decorateQB(qb, 'claim', args);
            qb = qb.leftJoinAndSelect('claim.credential', 'credential');
            if (context.authorizedDID) {
                qb = qb.andWhere(new typeorm_1.Brackets((qb) => {
                    qb.where('claim.subject = :ident', { ident: context.authorizedDID }).orWhere('claim.issuer = :ident', {
                        ident: context.authorizedDID,
                    });
                }));
            }
            return qb;
        });
    }
    dataStoreORMGetVerifiableCredentialsByClaims(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            // FIXME this breaks if args has order param
            const claims = yield (yield this.claimsQuery(args, context)).getMany();
            return claims.map((claim) => ({
                hash: claim.credential.hash,
                verifiableCredential: claim.credential.raw,
            }));
        });
    }
    dataStoreORMGetVerifiableCredentialsByClaimsCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.claimsQuery(args, context)).getCount();
        });
    }
    // Credentials
    credentialsQuery(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const where = createWhereObject(args);
            let qb = (yield this.dbConnection)
                .getRepository(credential_1.Credential)
                .createQueryBuilder('credential')
                .leftJoinAndSelect('credential.issuer', 'issuer')
                .leftJoinAndSelect('credential.subject', 'subject')
                .where(where);
            qb = decorateQB(qb, 'credential', args);
            if (context.authorizedDID) {
                qb = qb.andWhere(new typeorm_1.Brackets((qb) => {
                    qb.where('credential.subject = :ident', { ident: context.authorizedDID }).orWhere('credential.issuer = :ident', {
                        ident: context.authorizedDID,
                    });
                }));
            }
            return qb;
        });
    }
    dataStoreORMGetVerifiableCredentials(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const credentials = yield (yield this.credentialsQuery(args, context)).getMany();
            return credentials.map((vc) => ({
                hash: vc.hash,
                verifiableCredential: vc.raw,
            }));
        });
    }
    dataStoreORMGetVerifiableCredentialsCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.credentialsQuery(args, context)).getCount();
        });
    }
    // Presentations
    presentationsQuery(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const where = createWhereObject(args);
            let qb = (yield this.dbConnection)
                .getRepository(presentation_1.Presentation)
                .createQueryBuilder('presentation')
                .leftJoinAndSelect('presentation.holder', 'holder')
                .leftJoinAndSelect('presentation.verifier', 'verifier')
                .where(where);
            qb = decorateQB(qb, 'presentation', args);
            qb = addVerifierQuery(args, qb);
            if (context.authorizedDID) {
                qb = qb.andWhere(new typeorm_1.Brackets((qb) => {
                    qb.where('verifier.did = :ident', {
                        ident: context.authorizedDID,
                    }).orWhere('presentation.holder = :ident', { ident: context.authorizedDID });
                }));
            }
            return qb;
        });
    }
    dataStoreORMGetVerifiablePresentations(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const presentations = yield (yield this.presentationsQuery(args, context)).getMany();
            return presentations.map((vp) => ({
                hash: vp.hash,
                verifiablePresentation: vp.raw,
            }));
        });
    }
    dataStoreORMGetVerifiablePresentationsCount(args, context) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.presentationsQuery(args, context)).getCount();
        });
    }
}
exports.DataStoreORM = DataStoreORM;
function opToSQL(item) {
    var _a, _b;
    switch (item.op) {
        case 'IsNull':
            return ['IS NULL', ''];
        case 'Like':
            if (((_a = item.value) === null || _a === void 0 ? void 0 : _a.length) != 1)
                throw Error('Operation Equal requires one value');
            return ['LIKE :value', item.value[0]];
        case 'Equal':
            if (((_b = item.value) === null || _b === void 0 ? void 0 : _b.length) != 1)
                throw Error('Operation Equal requires one value');
            return ['= :value', item.value[0]];
        case 'Any':
        case 'Between':
        case 'LessThan':
        case 'LessThanOrEqual':
        case 'MoreThan':
        case 'MoreThanOrEqual':
            throw new Error(`${item.op} not compatible with DID argument`);
        case 'In':
        default:
            return ['IN (:...value)', item.value];
    }
}
function addVerifierQuery(input, qb) {
    if (!input) {
        return qb;
    }
    if (!Array.isArray(input.where)) {
        return qb;
    }
    const verifierWhere = input.where.find((item) => item.column === 'verifier');
    if (!verifierWhere) {
        return qb;
    }
    const [op, value] = opToSQL(verifierWhere);
    return qb.andWhere(`verifier.did ${op}`, { value });
}
function createWhereObject(input) {
    var _a, _b, _c, _d, _e, _f, _g;
    const where = {};
    if (input === null || input === void 0 ? void 0 : input.where) {
        for (const item of input.where) {
            if (item.column === 'verifier') {
                continue;
            }
            switch (item.op) {
                case 'Any':
                    if (!Array.isArray(item.value))
                        throw Error('Operator Any requires value to be an array');
                    where[item.column] = (0, typeorm_1.Any)(item.value);
                    break;
                case 'Between':
                    if (((_a = item.value) === null || _a === void 0 ? void 0 : _a.length) != 2)
                        throw Error('Operation Between requires two values');
                    where[item.column] = (0, typeorm_1.Between)(item.value[0], item.value[1]);
                    break;
                case 'Equal':
                    if (((_b = item.value) === null || _b === void 0 ? void 0 : _b.length) != 1)
                        throw Error('Operation Equal requires one value');
                    where[item.column] = (0, typeorm_1.Equal)(item.value[0]);
                    break;
                case 'IsNull':
                    where[item.column] = (0, typeorm_1.IsNull)();
                    break;
                case 'LessThan':
                    if (((_c = item.value) === null || _c === void 0 ? void 0 : _c.length) != 1)
                        throw Error('Operation LessThan requires one value');
                    where[item.column] = (0, typeorm_1.LessThan)(item.value[0]);
                    break;
                case 'LessThanOrEqual':
                    if (((_d = item.value) === null || _d === void 0 ? void 0 : _d.length) != 1)
                        throw Error('Operation LessThanOrEqual requires one value');
                    where[item.column] = (0, typeorm_1.LessThanOrEqual)(item.value[0]);
                    break;
                case 'Like':
                    if (((_e = item.value) === null || _e === void 0 ? void 0 : _e.length) != 1)
                        throw Error('Operation Like requires one value');
                    where[item.column] = (0, typeorm_1.Like)(item.value[0]);
                    break;
                case 'MoreThan':
                    if (((_f = item.value) === null || _f === void 0 ? void 0 : _f.length) != 1)
                        throw Error('Operation MoreThan requires one value');
                    where[item.column] = (0, typeorm_1.MoreThan)(item.value[0]);
                    break;
                case 'MoreThanOrEqual':
                    if (((_g = item.value) === null || _g === void 0 ? void 0 : _g.length) != 1)
                        throw Error('Operation MoreThanOrEqual requires one value');
                    where[item.column] = (0, typeorm_1.MoreThanOrEqual)(item.value[0]);
                    break;
                case 'In':
                default:
                    if (!Array.isArray(item.value))
                        throw Error('Operator IN requires value to be an array');
                    where[item.column] = (0, typeorm_1.In)(item.value);
            }
            if (item.not === true) {
                where[item.column] = (0, typeorm_1.Not)(where[item.column]);
            }
        }
    }
    return where;
}
function decorateQB(qb, tableName, input) {
    if (input === null || input === void 0 ? void 0 : input.skip)
        qb = qb.skip(input.skip);
    if (input === null || input === void 0 ? void 0 : input.take)
        qb = qb.take(input.take);
    if (input === null || input === void 0 ? void 0 : input.order) {
        for (const item of input.order) {
            qb = qb.orderBy(qb.connection.driver.escape(tableName) + '.' + qb.connection.driver.escape(item.column), item.direction);
        }
    }
    return qb;
}
//# sourceMappingURL=data-store-orm.js.map