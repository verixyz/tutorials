"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDResolverPlugin = void 0;
const core_1 = require("@verixyz/core");
const did_resolver_1 = require("did-resolver");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('verixyz:resolver');
class DIDResolverPlugin {
    constructor(options) {
        this.schema = core_1.schema.IResolver;
        if (!options.resolver)
            throw Error('Missing resolver');
        this.didResolver = options.resolver;
        this.methods = {
            resolveDid: this.resolveDid.bind(this),
            getDIDComponentById: this.getDIDComponentById.bind(this),
        };
    }
    /** {@inheritDoc @verixyz/core#IResolver.resolveDid} */
    resolveDid({ didUrl, options, }) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('Resolving %s', didUrl);
            const resolverOptions = Object.assign({ accept: 'application/did+ld+json' }, options);
            // ensure the required fields are present, even if the resolver is not compliant
            const cannedResponse = {
                didDocumentMetadata: {},
                didResolutionMetadata: {},
                didDocument: null,
            };
            const resolution = yield this.didResolver.resolve(didUrl, resolverOptions);
            return Object.assign(Object.assign({}, cannedResponse), resolution);
        });
    }
    /** {@inheritDoc @verixyz/core#IResolver.getDIDComponentById} */
    getDIDComponentById({ didDocument, didUrl, section, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            debug('Resolving %s', didUrl);
            const did = ((_a = (0, did_resolver_1.parse)(didUrl)) === null || _a === void 0 ? void 0 : _a.did) || didDocument.id;
            const doc = didDocument;
            const mainSections = [...(doc.verificationMethod || []), ...(doc.publicKey || []), ...(doc.service || [])];
            const subsection = section ? [...(doc[section] || [])] : mainSections;
            let result = subsection.find((item) => {
                if (typeof item === 'string') {
                    return item === didUrl || `${did}${item}` === didUrl;
                }
                else {
                    return item.id === didUrl || `${did}${item.id}` === didUrl;
                }
            });
            if (typeof result === 'string') {
                result = mainSections.find((item) => item.id === didUrl || `${did}${item.id}` === didUrl);
            }
            if (!result) {
                const err = `not_found: DID document fragment (${didUrl}) could not be located.`;
                debug(err);
                throw new Error(err);
            }
            else if (result.id.startsWith('#')) {
                // fix did documents that use only the fragment part as key ID
                result.id = `${did}${result.id}`;
            }
            return result;
        });
    }
}
exports.DIDResolverPlugin = DIDResolverPlugin;
//# sourceMappingURL=resolver.js.map