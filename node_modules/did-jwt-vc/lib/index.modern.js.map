{"version":3,"file":"index.modern.js","sources":["../src/types.ts","../src/converters.ts","../src/validators.ts","../src/index.ts"],"sourcesContent":["import { Signer, JWTVerified, JWTHeader, JWTOptions } from 'did-jwt'\n\nexport const JWT_ALG = 'ES256K'\nexport const DID_FORMAT = /^did:([a-zA-Z0-9_]+):([:[a-zA-Z0-9_.-]+)(\\/[^#]*)?(#.*)?$/\nexport const JWT_FORMAT = /^[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*$/\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1'\nexport const DEFAULT_VC_TYPE = 'VerifiableCredential'\nexport const DEFAULT_VP_TYPE = 'VerifiablePresentation'\nexport const DEFAULT_JWT_PROOF_TYPE = 'JwtProof2020'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type JwtCredentialSubject = Record<string, any>\n\nexport interface CredentialStatus {\n  id: string\n  type: string\n}\n\n/**\n * A JWT payload representation of a Credential\n * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding\n */\nexport interface JwtCredentialPayload {\n  iss?: string\n  sub?: string\n  vc: Extensible<{\n    '@context': string[] | string\n    type: string[] | string\n    credentialSubject: JwtCredentialSubject\n    credentialStatus?: CredentialStatus\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    evidence?: any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    termsOfUse?: any\n  }>\n  nbf?: number\n  aud?: string | string[]\n  exp?: number\n  jti?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * A JWT payload representation of a Presentation\n * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding\n */\nexport interface JwtPresentationPayload {\n  vp: Extensible<{\n    '@context': string[] | string\n    type: string[] | string\n    verifiableCredential?: VerifiableCredential[] | VerifiableCredential\n  }>\n  iss?: string\n  aud?: string | string[]\n  nbf?: number\n  exp?: number\n  jti?: string\n  nonce?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport type IssuerType = Extensible<{ id: string }> | string\nexport type DateType = string | Date\n/**\n * used as input when creating Verifiable Credentials\n */\ninterface FixedCredentialPayload {\n  '@context': string | string[]\n  id?: string\n  type: string | string[]\n  issuer: IssuerType\n  issuanceDate: DateType\n  expirationDate?: DateType\n  credentialSubject: Extensible<{\n    id?: string\n  }>\n  credentialStatus?: CredentialStatus\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  evidence?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  termsOfUse?: any\n}\n\n/**\n * A more flexible representation of a {@link W3CCredential} that can be used as input to methods\n * that expect it.\n */\nexport type CredentialPayload = Extensible<FixedCredentialPayload>\n\n/**\n * This is meant to reflect unambiguous types for the properties in `CredentialPayload`\n */\ninterface NarrowCredentialDefinitions {\n  '@context': string[]\n  type: string[]\n  issuer: Exclude<IssuerType, string>\n  issuanceDate: string\n  expirationDate?: string\n}\n\n/**\n * Replaces the matching property types of T with the ones in U\n */\ntype Replace<T, U> = Omit<T, keyof U> & U\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Extensible<T> = T & { [x: string]: any }\n\n/**\n * This data type represents a parsed VerifiableCredential.\n * It is meant to be an unambiguous representation of the properties of a Credential and is usually the result of a transformation method.\n *\n * `issuer` is always an object with an `id` property and potentially other app specific issuer claims\n * `issuanceDate` is an ISO DateTime string\n * `expirationDate`, is a nullable ISO DateTime string\n *\n * Any JWT specific properties are transformed to the broader W3C variant and any app specific properties are left intact\n */\nexport type W3CCredential = Extensible<Replace<FixedCredentialPayload, NarrowCredentialDefinitions>>\n\n/**\n * used as input when creating Verifiable Presentations\n */\nexport interface FixedPresentationPayload {\n  '@context': string | string[]\n  type: string | string[]\n  id?: string\n  verifiableCredential?: VerifiableCredential[]\n  holder: string\n  verifier?: string | string[]\n  issuanceDate?: string\n  expirationDate?: string\n}\n\n/**\n * A more flexible representation of a {@link W3CPresentation} that can be used as input to methods\n * that expect it.\n */\nexport type PresentationPayload = Extensible<FixedPresentationPayload>\n\ninterface NarrowPresentationDefinitions {\n  '@context': string[]\n  type: string[]\n  verifier: string[]\n  verifiableCredential?: Verifiable<W3CCredential>[]\n}\n\n/**\n * This data type represents a parsed Presentation payload.\n * It is meant to be an unambiguous representation of the properties of a Presentation and is usually the result of a transformation method.\n *\n * The `verifiableCredential` array should contain parsed `Verifiable<Credential>` elements.\n * Any JWT specific properties are transformed to the broader W3C variant and any other app specific properties are left intact.\n */\nexport type W3CPresentation = Extensible<Replace<FixedPresentationPayload, NarrowPresentationDefinitions>>\n\nexport interface Proof {\n  type?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents a readonly representation of a verifiable object, including the {@link Proof}\n * property that can be used to verify it.\n */\nexport type Verifiable<T> = Readonly<T> & { readonly proof: Proof }\nexport type JWT = string\n\n/**\n * A union type for both possible representations of a Credential (JWT and W3C standard)\n *\n * @see https://www.w3.org/TR/vc-data-model/#proof-formats\n */\nexport type VerifiableCredential = JWT | Verifiable<W3CCredential>\n\n/**\n * A union type for both possible representations of a Presentation (JWT and W3C standard)\n *\n * @see https://www.w3.org/TR/vc-data-model/#proof-formats\n */\nexport type VerifiablePresentation = JWT | Verifiable<W3CPresentation>\n\nexport type VerifiedJWT = JWTVerified\n\n/**\n * Represents the result of a Presentation verification.\n * It includes the properties produced by `did-jwt` and a W3C compliant representation of\n * the Presentation that was just verified.\n *\n * This is usually the result of a verification method and not meant to be created by generic code.\n */\nexport type VerifiedPresentation = VerifiedJWT & {\n  verifiablePresentation: Verifiable<W3CPresentation>\n}\n\n/**\n * Represents the result of a Credential verification.\n * It includes the properties produced by `did-jwt` and a W3C compliant representation of\n * the Credential that was just verified.\n *\n * This is usually the result of a verification method and not meant to be created by generic code.\n */\nexport type VerifiedCredential = VerifiedJWT & {\n  verifiableCredential: Verifiable<W3CCredential>\n}\n\n/**\n * Represents a tuple of a DID-URL with a `Signer` and associated algorithm.\n */\nexport interface Issuer {\n  did: string\n  signer: Signer\n  alg?: string\n}\n\n/**\n * Represents the Creation Options that can be passed to the createVerifiableCredentialJwt method.\n */\nexport interface CreateCredentialOptions extends Partial<JWTOptions> {\n  /**\n   * Determines whether the JSON->JWT transformation will remove the original fields from the input payload.\n   * See https://www.w3.org/TR/vc-data-model/#jwt-encoding\n   *\n   * @default true\n   */\n  removeOriginalFields?: boolean\n\n  /**\n   * Allows including or overriding some header parameters for the resulting JWT.\n   * If the issuer or holder does not list an `alg`, then the one specified in `header` will be used\n   */\n  header?: Partial<JWTHeader>\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents the Verification Options that can be passed to the verifyCredential method.\n * These options are forwarded to the lower level verification code\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type VerifyCredentialOptions = Record<string, any>\n\n/**\n * Represents the Verification Options that can be passed to the verifyPresentation method.\n * The verification will fail if given options are NOT satisfied.\n */\nexport interface VerifyPresentationOptions extends VerifyCredentialOptions {\n  domain?: string\n  challenge?: string\n}\n\n/**\n * Represents the Creation Options that can be passed to the createVerifiablePresentationJwt method.\n */\nexport interface CreatePresentationOptions extends CreateCredentialOptions {\n  domain?: string\n  challenge?: string\n}\n","import {\n  VerifiableCredential,\n  JWT,\n  JwtPresentationPayload,\n  JwtCredentialPayload,\n  JWT_FORMAT,\n  DEFAULT_JWT_PROOF_TYPE,\n  DEFAULT_CONTEXT,\n  DEFAULT_VC_TYPE,\n  CredentialPayload,\n  W3CCredential,\n  Verifiable,\n  PresentationPayload,\n  W3CPresentation,\n} from './types'\nimport { decodeJWT } from 'did-jwt'\n\n/*\n * Additional W3C VC fields:\n * These are defined as optional top-level properties in the W3C spec but are not mapped to top-level JWT names,\n * so they should be moved inside the \"vc\" object when transforming to a JWT.\n * Conversely, they should be moved out of the \"vc\" object when transforming from a JWT to W3C JSON.\n */\nconst additionalPropNames = ['evidence', 'termsOfUse', 'refreshService', 'credentialSchema', 'credentialStatus']\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function asArray(arg: any | any[]): any[] {\n  return Array.isArray(arg) ? arg : [arg]\n}\n\nfunction deepCopy<T>(source: T): T {\n  return Array.isArray(source)\n    ? source.map((item) => deepCopy(item))\n    : source instanceof Date\n    ? new Date(source.getTime())\n    : source && typeof source === 'object'\n    ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n        Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop) as NonNullable<PropertyDescriptor>)\n        o[prop] = deepCopy(source[prop as keyof T])\n        return o\n      }, Object.create(Object.getPrototypeOf(source)))\n    : (source as T)\n}\n\nexport function notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  return value !== null && value !== undefined\n}\n\nfunction cleanUndefined<T>(input: T): T {\n  if (typeof input !== 'object') {\n    return input\n  }\n  const obj = { ...input }\n  Object.keys(obj).forEach((key) => obj[key as keyof T] === undefined && delete obj[key as keyof T])\n  return obj\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isLegacyAttestationFormat(payload: Record<string, any>): boolean {\n  // payload is an object and has all the required fields of old attestation format\n  return typeof payload === 'object' && payload.sub && payload.iss && payload.claim && payload.iat\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function attestationToVcFormat(payload: Record<string, any>): JwtCredentialPayload {\n  const { iat, nbf, claim, vc, ...rest } = payload\n  const result: JwtCredentialPayload = {\n    ...rest,\n    nbf: nbf ? nbf : iat,\n    vc: {\n      '@context': [DEFAULT_CONTEXT],\n      type: [DEFAULT_VC_TYPE],\n      credentialSubject: claim,\n    },\n  }\n  if (vc) payload.issVc = vc\n  return result\n}\n\nfunction normalizeJwtCredentialPayload(\n  input: Partial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): W3CCredential {\n  let result: Partial<CredentialPayload> = deepCopy(input)\n\n  if (isLegacyAttestationFormat(input)) {\n    result = attestationToVcFormat(input)\n  }\n\n  // FIXME: handle case when credentialSubject(s) are not object types\n  result.credentialSubject = { ...input.credentialSubject, ...input.vc?.credentialSubject }\n  if (input.sub && !input.credentialSubject?.id && result.credentialSubject) {\n    result.credentialSubject.id = input.sub\n    if (removeOriginalFields) {\n      delete result.sub\n    }\n  }\n  if (removeOriginalFields) {\n    delete result.vc?.credentialSubject\n  }\n\n  if (typeof input.issuer === 'undefined' || typeof input.issuer === 'object') {\n    result.issuer = cleanUndefined({ id: input.iss, ...input.issuer })\n    if (removeOriginalFields && !input.issuer?.id) {\n      delete result.iss\n    }\n  }\n\n  if (!input.id && input.jti) {\n    result.id = result.id || result.jti\n    if (removeOriginalFields) {\n      delete result.jti\n    }\n  }\n\n  const types = [...asArray(result.type), ...asArray(result.vc?.type)].filter(notEmpty)\n  result.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.vc?.type\n  }\n\n  for (const prop of additionalPropNames) {\n    if (input.vc && input.vc[prop]) {\n      if (!result[prop]) {\n        result[prop] = input.vc[prop]\n      }\n      if (removeOriginalFields) {\n        delete result.vc[prop]\n      }\n    }\n  }\n\n  const contextArray: string[] = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vc?.['@context']),\n  ].filter(notEmpty)\n  result['@context'] = [...new Set(contextArray)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result.vc?.['@context']\n  }\n\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString()\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf\n      } else {\n        delete result.iat\n      }\n    }\n  }\n\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString()\n    if (removeOriginalFields) {\n      delete result.exp\n    }\n  }\n\n  if (removeOriginalFields) {\n    if (result.vc && Object.keys(result.vc).length === 0) {\n      delete result.vc\n    }\n  }\n\n  // FIXME: interpret `aud` property as `verifier`\n\n  return result as W3CCredential\n}\n\nfunction normalizeJwtCredential(input: JWT, removeOriginalFields = true): Verifiable<W3CCredential> {\n  let decoded\n  try {\n    decoded = decodeJWT(input)\n  } catch (e) {\n    throw new TypeError('unknown credential format')\n  }\n  return {\n    ...normalizeJwtCredentialPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input,\n    },\n  }\n}\n\n/**\n * Normalizes a credential payload into an unambiguous W3C credential data type\n * In case of conflict, Existing W3C Credential specific properties take precedence,\n * except for arrays and object types which get merged.\n * @param input either a JWT or JWT payload, or a VerifiableCredential\n */\nexport function normalizeCredential(\n  input: Partial<VerifiableCredential> | Partial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): Verifiable<W3CCredential> {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtCredential(input, removeOriginalFields)\n    } else {\n      let parsed: Record<string, unknown>\n      try {\n        parsed = JSON.parse(input)\n      } catch (e) {\n        throw new TypeError('unknown credential format')\n      }\n      return normalizeCredential(parsed, removeOriginalFields)\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return deepCopy({ ...normalizeJwtCredential(input.proof.jwt, removeOriginalFields), proof: input.proof })\n  } else {\n    // TODO: test that it accepts JWT payload, CredentialPayload, VerifiableCredential\n    // TODO: test that it correctly propagates proof, if any\n    return { proof: {}, ...normalizeJwtCredentialPayload(input, removeOriginalFields) }\n  }\n}\n\n/**\n * type used to signal a very loose input is accepted\n */\ntype DeepPartial<T> = T extends Record<string, unknown> ? { [K in keyof T]?: DeepPartial<T[K]> } : T\n\n/**\n * Transforms a W3C Credential payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input either a JWT payload or a CredentialPayloadInput\n */\nexport function transformCredentialInput(\n  input: Partial<CredentialPayload> | DeepPartial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): JwtCredentialPayload {\n  if (Array.isArray(input.credentialSubject)) throw Error('credentialSubject of type array not supported')\n\n  const result: Partial<JwtCredentialPayload> = deepCopy({\n    vc: { ...input.vc },\n    ...input,\n  }) as Partial<JwtCredentialPayload>\n  result.vc = result.vc as NonNullable<typeof result.vc>\n\n  const credentialSubject = { ...input.credentialSubject, ...input.vc?.credentialSubject }\n  if (!input.sub) {\n    result.sub = input.credentialSubject?.id\n    if (removeOriginalFields) {\n      delete credentialSubject.id\n    }\n  }\n\n  const contextEntries = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vc?.['@context']),\n  ].filter(notEmpty)\n  result.vc['@context'] = [...new Set(contextEntries)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result['@context']\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vc?.type)].filter(notEmpty)\n  result.vc.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.type\n  }\n\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id\n    if (removeOriginalFields) {\n      delete result.id\n    }\n  }\n\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate)\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.issuanceDate\n      }\n    }\n  }\n\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate)\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.expirationDate\n      }\n    }\n  }\n\n  if (input.issuer && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.issuer === 'object') {\n      result.iss = input.issuer?.id\n      if (removeOriginalFields) {\n        delete result.issuer.id\n        if (Object.keys(result.issuer).length === 0) {\n          delete result.issuer\n        }\n      }\n    } else if (typeof input.issuer === 'string') {\n      result.iss = input.iss || '' + input.issuer\n      if (removeOriginalFields) {\n        delete result.issuer\n      }\n    } else {\n      // nop\n    }\n  }\n\n  result.vc.credentialSubject = credentialSubject\n  if (removeOriginalFields) {\n    delete result.credentialSubject\n  }\n\n  for (const prop of additionalPropNames) {\n    if (input[prop]) {\n      if (!result.vc[prop]) {\n        result.vc[prop] = input[prop]\n      }\n      if (removeOriginalFields) {\n        delete result[prop]\n      }\n    }\n  }\n\n  return result as JwtCredentialPayload\n}\n\nfunction normalizeJwtPresentationPayload(\n  input: DeepPartial<JwtPresentationPayload>,\n  removeOriginalFields = true\n): W3CPresentation {\n  const result: Partial<PresentationPayload> = deepCopy(input)\n\n  result.verifiableCredential = [\n    ...asArray(input.verifiableCredential),\n    ...asArray(input.vp?.verifiableCredential),\n  ].filter(notEmpty)\n  result.verifiableCredential = result.verifiableCredential.map((cred) => {\n    return normalizeCredential(cred, removeOriginalFields)\n  })\n  if (removeOriginalFields) {\n    delete result.vp?.verifiableCredential\n  }\n\n  if (input.iss && !input.holder) {\n    result.holder = input.iss\n    if (removeOriginalFields) {\n      delete result.iss\n    }\n  }\n\n  if (input.aud) {\n    result.verifier = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty)\n    result.verifier = [...new Set(result.verifier)]\n    if (removeOriginalFields) {\n      delete result.aud\n    }\n  }\n\n  if (input.jti && Object.getOwnPropertyNames(input).indexOf('id') === -1) {\n    result.id = input.id || input.jti\n    if (removeOriginalFields) {\n      delete result.jti\n    }\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty)\n  result.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.vp?.type\n  }\n\n  const contexts = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vp?.['@context']),\n  ].filter(notEmpty)\n  result['@context'] = [...new Set(contexts)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result.vp?.['@context']\n  }\n\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString()\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf\n      } else {\n        delete result.iat\n      }\n    }\n  }\n\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString()\n    if (removeOriginalFields) {\n      delete result.exp\n    }\n  }\n\n  if (result.vp && Object.keys(result.vp).length === 0) {\n    if (removeOriginalFields) {\n      delete result.vp\n    }\n  }\n\n  return result as W3CPresentation\n}\n\nfunction normalizeJwtPresentation(input: JWT, removeOriginalFields = true): Verifiable<W3CPresentation> {\n  let decoded\n  try {\n    decoded = decodeJWT(input)\n  } catch (e) {\n    throw new TypeError('unknown presentation format')\n  }\n  return {\n    ...normalizeJwtPresentationPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input,\n    },\n  }\n}\n\n/**\n * Normalizes a presentation payload into an unambiguous W3C Presentation data type\n * @param input either a JWT or JWT payload, or a VerifiablePresentation\n */\nexport function normalizePresentation(\n  input: Partial<PresentationPayload> | DeepPartial<JwtPresentationPayload> | JWT,\n  removeOriginalFields = true\n): Verifiable<W3CPresentation> {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtPresentation(input, removeOriginalFields)\n    } else {\n      let parsed: Record<string, unknown>\n      try {\n        parsed = JSON.parse(input)\n      } catch (e) {\n        throw new TypeError('unknown presentation format')\n      }\n      return normalizePresentation(parsed, removeOriginalFields)\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return { ...normalizeJwtPresentation(input.proof.jwt, removeOriginalFields), proof: input.proof }\n  } else {\n    // TODO: test that it accepts JWT payload, PresentationPayload, VerifiablePresentation\n    // TODO: test that it correctly propagates proof, if any\n    return { proof: {}, ...normalizeJwtPresentationPayload(input, removeOriginalFields) }\n  }\n}\n\n/**\n * Transforms a W3C Presentation payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input either a JWT payload or a CredentialPayloadInput\n */\nexport function transformPresentationInput(\n  input: Partial<PresentationPayload> | DeepPartial<JwtPresentationPayload>,\n  removeOriginalFields = true\n): JwtPresentationPayload {\n  const result: Partial<JwtPresentationPayload> = deepCopy({\n    vp: { ...input.vp },\n    ...input,\n  }) as Partial<JwtPresentationPayload>\n  result.vp = result.vp as NonNullable<typeof result.vp>\n\n  const contextEntries = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vp?.['@context']),\n  ].filter(notEmpty)\n  result.vp['@context'] = [...new Set(contextEntries)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result['@context']\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty)\n  result.vp.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.type\n  }\n\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id\n    if (removeOriginalFields) {\n      delete result.id\n    }\n  }\n\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate)\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.issuanceDate\n      }\n    }\n  }\n\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate)\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.expirationDate\n      }\n    }\n  }\n\n  if (result.verifiableCredential || result.vp?.verifiableCredential) {\n    result.vp.verifiableCredential = [\n      ...asArray(result.verifiableCredential),\n      ...asArray(result.vp?.verifiableCredential),\n    ]\n      .filter(notEmpty)\n      .map((credential: VerifiableCredential) => {\n        if (typeof credential === 'object' && credential.proof?.jwt) {\n          return credential.proof.jwt\n        } else {\n          return credential\n        }\n      })\n  }\n\n  if (removeOriginalFields) {\n    delete result.verifiableCredential\n  }\n\n  if (input.holder && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.holder === 'string') {\n      result.iss = input.holder\n      if (removeOriginalFields) {\n        delete result.holder\n      }\n    } else {\n      // nop\n    }\n  }\n\n  if (input.verifier) {\n    const audience = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty)\n    result.aud = [...new Set(audience)]\n    if (removeOriginalFields) {\n      delete result.verifier\n    }\n  }\n\n  return result as JwtPresentationPayload\n}\n","import { DEFAULT_CONTEXT, DEFAULT_VC_TYPE, DEFAULT_VP_TYPE, JWT_FORMAT } from './types'\nimport { JwtCredentialSubject, DateType } from './types'\nimport { VerifiableCredential } from '.'\nimport { asArray } from './converters'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isDateObject(input: any): input is Date {\n  return input && !isNaN(input) && Object.prototype.toString.call(input) === '[object Date]'\n}\n\nexport function validateJwtFormat(value: VerifiableCredential): void {\n  if (typeof value === 'string' && !value.match(JWT_FORMAT)) {\n    throw new TypeError(`\"${value}\" is not a valid JWT format`)\n  }\n}\n\n// The main scenario we want to guard against is having a timestamp in milliseconds\n// instead of seconds (ex: from new Date().getTime()).\n// We will check the number of digits and assume that any number with 12 or more\n// digits is a millisecond timestamp.\n// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)\n// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)\n// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)\nexport function validateTimestamp(value: number | DateType): void {\n  if (typeof value === 'number') {\n    if (!(Number.isInteger(value) && value < 100000000000)) {\n      throw new TypeError(`\"${value}\" is not a unix timestamp in seconds`)\n    }\n  } else if (typeof value === 'string') {\n    validateTimestamp(Math.floor(new Date(value).valueOf() / 1000))\n  } else if (!isDateObject(value)) {\n    throw new TypeError(`\"${value}\" is not a valid time`)\n  }\n}\n\nexport function validateContext(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_CONTEXT) === -1) {\n    throw new TypeError(`@context is missing default context \"${DEFAULT_CONTEXT}\"`)\n  }\n}\n\nexport function validateVcType(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VC_TYPE}\"`)\n  }\n}\n\nexport function validateVpType(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VP_TYPE}\"`)\n  }\n}\n\nexport function validateCredentialSubject(value: JwtCredentialSubject): void {\n  if (Object.keys(value).length === 0) {\n    throw new TypeError('credentialSubject must not be empty')\n  }\n}\n","import { createJWT, verifyJWT } from 'did-jwt'\nimport { Resolvable } from 'did-resolver'\nimport * as validators from './validators'\nimport {\n  JwtCredentialPayload,\n  Issuer,\n  JwtPresentationPayload,\n  JWT,\n  VerifiablePresentation,\n  VerifiableCredential,\n  CredentialPayload,\n  PresentationPayload,\n  Verifiable,\n  W3CCredential,\n  W3CPresentation,\n  VerifiedCredential,\n  VerifiedPresentation,\n  VerifyPresentationOptions,\n  CreatePresentationOptions,\n  CreateCredentialOptions,\n  VerifyCredentialOptions,\n  JWT_ALG,\n} from './types'\nimport {\n  transformCredentialInput,\n  transformPresentationInput,\n  normalizeCredential,\n  normalizePresentation,\n  asArray,\n  notEmpty,\n} from './converters'\nexport {\n  Issuer,\n  CredentialPayload,\n  PresentationPayload,\n  JwtCredentialPayload,\n  JwtPresentationPayload,\n  VerifiableCredential,\n  VerifiablePresentation,\n  VerifiedCredential,\n  VerifiedPresentation,\n  Verifiable,\n  W3CCredential,\n  W3CPresentation,\n  transformCredentialInput,\n  transformPresentationInput,\n  normalizeCredential,\n  normalizePresentation,\n}\n\n/**\n * Creates a VerifiableCredential given a `CredentialPayload` or `JwtCredentialPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum spec\n * required spec.\n *\n * The `issuer` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload `CredentialPayload` or `JwtCredentialPayload`\n * @param issuer `Issuer` the DID, signer and algorithm that will sign the token\n * @return a `Promise` that resolves to the JWT encoded verifiable credential or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nexport async function createVerifiableCredentialJwt(\n  payload: JwtCredentialPayload | CredentialPayload,\n  issuer: Issuer,\n  options: CreateCredentialOptions = {}\n): Promise<JWT> {\n  const parsedPayload: JwtCredentialPayload = {\n    iat: undefined,\n    ...transformCredentialInput(payload, options.removeOriginalFields),\n  }\n  validateJwtCredentialPayload(parsedPayload)\n  return createJWT(\n    parsedPayload,\n    {\n      ...options,\n      issuer: issuer.did || parsedPayload.iss || '',\n      signer: issuer.signer,\n    },\n    {\n      ...options.header,\n      alg: issuer.alg || options.header?.alg || JWT_ALG,\n    }\n  )\n}\n\n/**\n * Creates a VerifiablePresentation JWT given a `PresentationPayload` or `JwtPresentationPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum spec\n * required spec.\n *\n * The `holder` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload `PresentationPayload` or `JwtPresentationPayload`\n * @param holder `Issuer` of the Presentation JWT (holder of the VC), signer and algorithm that will sign the token\n * @param options `CreatePresentationOptions` allows to pass additional values to the resulting JWT payload\n * @return a `Promise` that resolves to the JWT encoded verifiable presentation or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nexport async function createVerifiablePresentationJwt(\n  payload: JwtPresentationPayload | PresentationPayload,\n  holder: Issuer,\n  options: CreatePresentationOptions = {}\n): Promise<JWT> {\n  const parsedPayload: JwtPresentationPayload = {\n    iat: undefined,\n    ...transformPresentationInput(payload, options?.removeOriginalFields),\n  }\n\n  // add challenge to nonce\n  if (options.challenge && Object.getOwnPropertyNames(parsedPayload).indexOf('nonce') === -1) {\n    parsedPayload.nonce = options.challenge\n  }\n\n  // add domain to audience.\n  if (options.domain) {\n    const audience = [...asArray(options.domain), ...asArray(parsedPayload.aud)].filter(notEmpty)\n    parsedPayload.aud = [...new Set(audience)]\n  }\n\n  validateJwtPresentationPayload(parsedPayload)\n  return createJWT(\n    parsedPayload,\n    {\n      ...options,\n      issuer: holder.did || parsedPayload.iss || '',\n      signer: holder.signer,\n    },\n    {\n      ...options.header,\n      alg: holder.alg || options.header?.alg || JWT_ALG,\n    }\n  )\n}\n\nexport function validateJwtCredentialPayload(payload: JwtCredentialPayload): void {\n  validators.validateContext(payload.vc['@context'])\n  validators.validateVcType(payload.vc.type)\n  validators.validateCredentialSubject(payload.vc.credentialSubject)\n  if (payload.nbf) validators.validateTimestamp(payload.nbf)\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validateCredentialPayload(payload: CredentialPayload): void {\n  validators.validateContext(payload['@context'])\n  validators.validateVcType(payload.type)\n  validators.validateCredentialSubject(payload.credentialSubject)\n  if (payload.issuanceDate) validators.validateTimestamp(payload.issuanceDate)\n  if (payload.expirationDate) validators.validateTimestamp(payload.expirationDate)\n}\n\nexport function validateJwtPresentationPayload(payload: JwtPresentationPayload): void {\n  validators.validateContext(payload.vp['@context'])\n  validators.validateVpType(payload.vp.type)\n  // empty credential array is allowed\n  if (payload.vp.verifiableCredential && payload.vp.verifiableCredential.length >= 1) {\n    for (const vc of asArray(payload.vp.verifiableCredential)) {\n      if (typeof vc === 'string') {\n        validators.validateJwtFormat(vc)\n      } else {\n        validateCredentialPayload(vc)\n      }\n    }\n  }\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validatePresentationPayload(payload: PresentationPayload): void {\n  validators.validateContext(payload['@context'])\n  validators.validateVpType(payload.type)\n  // empty credential array is allowed\n  if (payload.verifiableCredential && payload.verifiableCredential.length >= 1) {\n    for (const vc of payload.verifiableCredential) {\n      if (typeof vc === 'string') {\n        validators.validateJwtFormat(vc)\n      } else {\n        validateCredentialPayload(vc)\n      }\n    }\n  }\n  if (payload.expirationDate) validators.validateTimestamp(payload.expirationDate)\n}\n\n/**\n * Verifies and validates a VerifiableCredential that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedCredential` or rejects with `TypeError` if the input is not\n * W3C compliant\n * @param vc the credential to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document of the JWT issuer\n */\nexport async function verifyCredential(\n  vc: JWT,\n  resolver: Resolvable,\n  options: VerifyCredentialOptions = {}\n): Promise<VerifiedCredential> {\n  const verified: Partial<VerifiedCredential> = await verifyJWT(vc, { resolver, ...options })\n  verified.verifiableCredential = normalizeCredential(verified.jwt as string, options?.removeOriginalFields)\n  validateCredentialPayload(verified.verifiableCredential)\n  return verified as VerifiedCredential\n}\n\n/**\n * Verifies that the given JwtPresentationPayload contains the appropriate options from VerifyPresentationOptions\n *\n * @param payload the JwtPresentationPayload to verify against\n * @param options the VerifyPresentationOptions that contain the optional values to verify.\n * @throws {Error} If VerifyPresentationOptions are not satisfied\n */\nexport function verifyPresentationPayloadOptions(\n  payload: JwtPresentationPayload,\n  options: VerifyPresentationOptions\n): void {\n  if (options.challenge && options.challenge !== payload.nonce) {\n    throw new Error(`Presentation does not contain the mandatory challenge (JWT: nonce) for : ${options.challenge}`)\n  }\n\n  if (options.domain) {\n    // aud might be array\n    let matchedAudience\n    if (payload.aud) {\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      matchedAudience = audArray.find((item) => options.domain === item)\n    }\n\n    if (typeof matchedAudience === 'undefined') {\n      throw new Error(`Presentation does not contain the mandatory domain (JWT: aud) for : ${options.domain}`)\n    }\n  }\n}\n\n/**\n * Verifies and validates a VerifiablePresentation that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedPresentation` or rejects with `TypeError` if the input is\n * not W3C compliant or the VerifyPresentationOptions are not satisfied.\n * @param presentation the presentation to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver a configured `Resolver` or an implementation of `Resolvable` that can provide the DID document of the JWT issuer (presentation holder)\n * @param options optional verification options that need to be satisfied\n */\nexport async function verifyPresentation(\n  presentation: JWT,\n  resolver: Resolvable,\n  options: VerifyPresentationOptions = {}\n): Promise<VerifiedPresentation> {\n  const verified: Partial<VerifiedPresentation> = await verifyJWT(presentation, { resolver, ...options })\n  verifyPresentationPayloadOptions(verified.payload as JwtPresentationPayload, options)\n  verified.verifiablePresentation = normalizePresentation(verified.jwt as string, options?.removeOriginalFields)\n  validatePresentationPayload(verified.verifiablePresentation)\n  return verified as VerifiedPresentation\n}\n"],"names":["JWT_FORMAT","DEFAULT_CONTEXT","additionalPropNames","asArray","arg","Array","isArray","deepCopy","source","map","item","Date","getTime","Object","getOwnPropertyNames","reduce","o","prop","defineProperty","getOwnPropertyDescriptor","create","getPrototypeOf","notEmpty","value","normalizeJwtCredentialPayload","input","removeOriginalFields","result","payload","sub","iss","claim","iat","nbf","vc","type","credentialSubject","issVc","attestationToVcFormat","_input$vc","_input$credentialSubj","id","issuer","obj","keys","forEach","key","undefined","cleanUndefined","_input$issuer","jti","types","_result$vc2","filter","Set","contextArray","context","_input$vc2","issuanceDate","toISOString","expirationDate","exp","length","normalizeJwtCredential","decoded","decodeJWT","e","TypeError","proof","jwt","normalizeCredential","test","parsed","JSON","parse","_input$proof","transformCredentialInput","Error","_input$vc3","_input$credentialSubj2","contextEntries","_input$vc4","_input$vc5","indexOf","converted","isNaN","Math","floor","_input$issuer2","normalizeJwtPresentationPayload","verifiableCredential","vp","_input$vp","cred","holder","aud","verifier","_input$vp2","contexts","_input$vp3","normalizeJwtPresentation","normalizePresentation","_input$proof2","transformPresentationInput","_input$vp4","_input$vp5","_result$vp4","_result$vp5","credential","_credential$proof","audience","validateJwtFormat","match","validateTimestamp","Number","isInteger","valueOf","prototype","toString","call","validateContext","validateVcType","validateVpType","validateCredentialSubject","createVerifiableCredentialJwt","options","parsedPayload","validateJwtCredentialPayload","createJWT","did","signer","header","alg","_options$header","createVerifiablePresentationJwt","challenge","nonce","domain","validateJwtPresentationPayload","_options$header2","validators","validateCredentialPayload","validatePresentationPayload","verifyCredential","resolver","verified","verifyJWT","verifyPresentationPayloadOptions","matchedAudience","find","verifyPresentation","presentation","verifiablePresentation"],"mappings":"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"}