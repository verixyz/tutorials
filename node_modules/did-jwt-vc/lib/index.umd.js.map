{"version":3,"file":"index.umd.js","sources":["../src/types.ts","../src/converters.ts","../src/validators.ts","../src/index.ts"],"sourcesContent":["import { Signer, JWTVerified, JWTHeader, JWTOptions } from 'did-jwt'\n\nexport const JWT_ALG = 'ES256K'\nexport const DID_FORMAT = /^did:([a-zA-Z0-9_]+):([:[a-zA-Z0-9_.-]+)(\\/[^#]*)?(#.*)?$/\nexport const JWT_FORMAT = /^[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*$/\nexport const DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1'\nexport const DEFAULT_VC_TYPE = 'VerifiableCredential'\nexport const DEFAULT_VP_TYPE = 'VerifiablePresentation'\nexport const DEFAULT_JWT_PROOF_TYPE = 'JwtProof2020'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type JwtCredentialSubject = Record<string, any>\n\nexport interface CredentialStatus {\n  id: string\n  type: string\n}\n\n/**\n * A JWT payload representation of a Credential\n * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding\n */\nexport interface JwtCredentialPayload {\n  iss?: string\n  sub?: string\n  vc: Extensible<{\n    '@context': string[] | string\n    type: string[] | string\n    credentialSubject: JwtCredentialSubject\n    credentialStatus?: CredentialStatus\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    evidence?: any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    termsOfUse?: any\n  }>\n  nbf?: number\n  aud?: string | string[]\n  exp?: number\n  jti?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * A JWT payload representation of a Presentation\n * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding\n */\nexport interface JwtPresentationPayload {\n  vp: Extensible<{\n    '@context': string[] | string\n    type: string[] | string\n    verifiableCredential?: VerifiableCredential[] | VerifiableCredential\n  }>\n  iss?: string\n  aud?: string | string[]\n  nbf?: number\n  exp?: number\n  jti?: string\n  nonce?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport type IssuerType = Extensible<{ id: string }> | string\nexport type DateType = string | Date\n/**\n * used as input when creating Verifiable Credentials\n */\ninterface FixedCredentialPayload {\n  '@context': string | string[]\n  id?: string\n  type: string | string[]\n  issuer: IssuerType\n  issuanceDate: DateType\n  expirationDate?: DateType\n  credentialSubject: Extensible<{\n    id?: string\n  }>\n  credentialStatus?: CredentialStatus\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  evidence?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  termsOfUse?: any\n}\n\n/**\n * A more flexible representation of a {@link W3CCredential} that can be used as input to methods\n * that expect it.\n */\nexport type CredentialPayload = Extensible<FixedCredentialPayload>\n\n/**\n * This is meant to reflect unambiguous types for the properties in `CredentialPayload`\n */\ninterface NarrowCredentialDefinitions {\n  '@context': string[]\n  type: string[]\n  issuer: Exclude<IssuerType, string>\n  issuanceDate: string\n  expirationDate?: string\n}\n\n/**\n * Replaces the matching property types of T with the ones in U\n */\ntype Replace<T, U> = Omit<T, keyof U> & U\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Extensible<T> = T & { [x: string]: any }\n\n/**\n * This data type represents a parsed VerifiableCredential.\n * It is meant to be an unambiguous representation of the properties of a Credential and is usually the result of a transformation method.\n *\n * `issuer` is always an object with an `id` property and potentially other app specific issuer claims\n * `issuanceDate` is an ISO DateTime string\n * `expirationDate`, is a nullable ISO DateTime string\n *\n * Any JWT specific properties are transformed to the broader W3C variant and any app specific properties are left intact\n */\nexport type W3CCredential = Extensible<Replace<FixedCredentialPayload, NarrowCredentialDefinitions>>\n\n/**\n * used as input when creating Verifiable Presentations\n */\nexport interface FixedPresentationPayload {\n  '@context': string | string[]\n  type: string | string[]\n  id?: string\n  verifiableCredential?: VerifiableCredential[]\n  holder: string\n  verifier?: string | string[]\n  issuanceDate?: string\n  expirationDate?: string\n}\n\n/**\n * A more flexible representation of a {@link W3CPresentation} that can be used as input to methods\n * that expect it.\n */\nexport type PresentationPayload = Extensible<FixedPresentationPayload>\n\ninterface NarrowPresentationDefinitions {\n  '@context': string[]\n  type: string[]\n  verifier: string[]\n  verifiableCredential?: Verifiable<W3CCredential>[]\n}\n\n/**\n * This data type represents a parsed Presentation payload.\n * It is meant to be an unambiguous representation of the properties of a Presentation and is usually the result of a transformation method.\n *\n * The `verifiableCredential` array should contain parsed `Verifiable<Credential>` elements.\n * Any JWT specific properties are transformed to the broader W3C variant and any other app specific properties are left intact.\n */\nexport type W3CPresentation = Extensible<Replace<FixedPresentationPayload, NarrowPresentationDefinitions>>\n\nexport interface Proof {\n  type?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents a readonly representation of a verifiable object, including the {@link Proof}\n * property that can be used to verify it.\n */\nexport type Verifiable<T> = Readonly<T> & { readonly proof: Proof }\nexport type JWT = string\n\n/**\n * A union type for both possible representations of a Credential (JWT and W3C standard)\n *\n * @see https://www.w3.org/TR/vc-data-model/#proof-formats\n */\nexport type VerifiableCredential = JWT | Verifiable<W3CCredential>\n\n/**\n * A union type for both possible representations of a Presentation (JWT and W3C standard)\n *\n * @see https://www.w3.org/TR/vc-data-model/#proof-formats\n */\nexport type VerifiablePresentation = JWT | Verifiable<W3CPresentation>\n\nexport type VerifiedJWT = JWTVerified\n\n/**\n * Represents the result of a Presentation verification.\n * It includes the properties produced by `did-jwt` and a W3C compliant representation of\n * the Presentation that was just verified.\n *\n * This is usually the result of a verification method and not meant to be created by generic code.\n */\nexport type VerifiedPresentation = VerifiedJWT & {\n  verifiablePresentation: Verifiable<W3CPresentation>\n}\n\n/**\n * Represents the result of a Credential verification.\n * It includes the properties produced by `did-jwt` and a W3C compliant representation of\n * the Credential that was just verified.\n *\n * This is usually the result of a verification method and not meant to be created by generic code.\n */\nexport type VerifiedCredential = VerifiedJWT & {\n  verifiableCredential: Verifiable<W3CCredential>\n}\n\n/**\n * Represents a tuple of a DID-URL with a `Signer` and associated algorithm.\n */\nexport interface Issuer {\n  did: string\n  signer: Signer\n  alg?: string\n}\n\n/**\n * Represents the Creation Options that can be passed to the createVerifiableCredentialJwt method.\n */\nexport interface CreateCredentialOptions extends Partial<JWTOptions> {\n  /**\n   * Determines whether the JSON->JWT transformation will remove the original fields from the input payload.\n   * See https://www.w3.org/TR/vc-data-model/#jwt-encoding\n   *\n   * @default true\n   */\n  removeOriginalFields?: boolean\n\n  /**\n   * Allows including or overriding some header parameters for the resulting JWT.\n   * If the issuer or holder does not list an `alg`, then the one specified in `header` will be used\n   */\n  header?: Partial<JWTHeader>\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents the Verification Options that can be passed to the verifyCredential method.\n * These options are forwarded to the lower level verification code\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type VerifyCredentialOptions = Record<string, any>\n\n/**\n * Represents the Verification Options that can be passed to the verifyPresentation method.\n * The verification will fail if given options are NOT satisfied.\n */\nexport interface VerifyPresentationOptions extends VerifyCredentialOptions {\n  domain?: string\n  challenge?: string\n}\n\n/**\n * Represents the Creation Options that can be passed to the createVerifiablePresentationJwt method.\n */\nexport interface CreatePresentationOptions extends CreateCredentialOptions {\n  domain?: string\n  challenge?: string\n}\n","import {\n  VerifiableCredential,\n  JWT,\n  JwtPresentationPayload,\n  JwtCredentialPayload,\n  JWT_FORMAT,\n  DEFAULT_JWT_PROOF_TYPE,\n  DEFAULT_CONTEXT,\n  DEFAULT_VC_TYPE,\n  CredentialPayload,\n  W3CCredential,\n  Verifiable,\n  PresentationPayload,\n  W3CPresentation,\n} from './types'\nimport { decodeJWT } from 'did-jwt'\n\n/*\n * Additional W3C VC fields:\n * These are defined as optional top-level properties in the W3C spec but are not mapped to top-level JWT names,\n * so they should be moved inside the \"vc\" object when transforming to a JWT.\n * Conversely, they should be moved out of the \"vc\" object when transforming from a JWT to W3C JSON.\n */\nconst additionalPropNames = ['evidence', 'termsOfUse', 'refreshService', 'credentialSchema', 'credentialStatus']\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function asArray(arg: any | any[]): any[] {\n  return Array.isArray(arg) ? arg : [arg]\n}\n\nfunction deepCopy<T>(source: T): T {\n  return Array.isArray(source)\n    ? source.map((item) => deepCopy(item))\n    : source instanceof Date\n    ? new Date(source.getTime())\n    : source && typeof source === 'object'\n    ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n        Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop) as NonNullable<PropertyDescriptor>)\n        o[prop] = deepCopy(source[prop as keyof T])\n        return o\n      }, Object.create(Object.getPrototypeOf(source)))\n    : (source as T)\n}\n\nexport function notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  return value !== null && value !== undefined\n}\n\nfunction cleanUndefined<T>(input: T): T {\n  if (typeof input !== 'object') {\n    return input\n  }\n  const obj = { ...input }\n  Object.keys(obj).forEach((key) => obj[key as keyof T] === undefined && delete obj[key as keyof T])\n  return obj\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isLegacyAttestationFormat(payload: Record<string, any>): boolean {\n  // payload is an object and has all the required fields of old attestation format\n  return typeof payload === 'object' && payload.sub && payload.iss && payload.claim && payload.iat\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function attestationToVcFormat(payload: Record<string, any>): JwtCredentialPayload {\n  const { iat, nbf, claim, vc, ...rest } = payload\n  const result: JwtCredentialPayload = {\n    ...rest,\n    nbf: nbf ? nbf : iat,\n    vc: {\n      '@context': [DEFAULT_CONTEXT],\n      type: [DEFAULT_VC_TYPE],\n      credentialSubject: claim,\n    },\n  }\n  if (vc) payload.issVc = vc\n  return result\n}\n\nfunction normalizeJwtCredentialPayload(\n  input: Partial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): W3CCredential {\n  let result: Partial<CredentialPayload> = deepCopy(input)\n\n  if (isLegacyAttestationFormat(input)) {\n    result = attestationToVcFormat(input)\n  }\n\n  // FIXME: handle case when credentialSubject(s) are not object types\n  result.credentialSubject = { ...input.credentialSubject, ...input.vc?.credentialSubject }\n  if (input.sub && !input.credentialSubject?.id && result.credentialSubject) {\n    result.credentialSubject.id = input.sub\n    if (removeOriginalFields) {\n      delete result.sub\n    }\n  }\n  if (removeOriginalFields) {\n    delete result.vc?.credentialSubject\n  }\n\n  if (typeof input.issuer === 'undefined' || typeof input.issuer === 'object') {\n    result.issuer = cleanUndefined({ id: input.iss, ...input.issuer })\n    if (removeOriginalFields && !input.issuer?.id) {\n      delete result.iss\n    }\n  }\n\n  if (!input.id && input.jti) {\n    result.id = result.id || result.jti\n    if (removeOriginalFields) {\n      delete result.jti\n    }\n  }\n\n  const types = [...asArray(result.type), ...asArray(result.vc?.type)].filter(notEmpty)\n  result.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.vc?.type\n  }\n\n  for (const prop of additionalPropNames) {\n    if (input.vc && input.vc[prop]) {\n      if (!result[prop]) {\n        result[prop] = input.vc[prop]\n      }\n      if (removeOriginalFields) {\n        delete result.vc[prop]\n      }\n    }\n  }\n\n  const contextArray: string[] = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vc?.['@context']),\n  ].filter(notEmpty)\n  result['@context'] = [...new Set(contextArray)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result.vc?.['@context']\n  }\n\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString()\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf\n      } else {\n        delete result.iat\n      }\n    }\n  }\n\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString()\n    if (removeOriginalFields) {\n      delete result.exp\n    }\n  }\n\n  if (removeOriginalFields) {\n    if (result.vc && Object.keys(result.vc).length === 0) {\n      delete result.vc\n    }\n  }\n\n  // FIXME: interpret `aud` property as `verifier`\n\n  return result as W3CCredential\n}\n\nfunction normalizeJwtCredential(input: JWT, removeOriginalFields = true): Verifiable<W3CCredential> {\n  let decoded\n  try {\n    decoded = decodeJWT(input)\n  } catch (e) {\n    throw new TypeError('unknown credential format')\n  }\n  return {\n    ...normalizeJwtCredentialPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input,\n    },\n  }\n}\n\n/**\n * Normalizes a credential payload into an unambiguous W3C credential data type\n * In case of conflict, Existing W3C Credential specific properties take precedence,\n * except for arrays and object types which get merged.\n * @param input either a JWT or JWT payload, or a VerifiableCredential\n */\nexport function normalizeCredential(\n  input: Partial<VerifiableCredential> | Partial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): Verifiable<W3CCredential> {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtCredential(input, removeOriginalFields)\n    } else {\n      let parsed: Record<string, unknown>\n      try {\n        parsed = JSON.parse(input)\n      } catch (e) {\n        throw new TypeError('unknown credential format')\n      }\n      return normalizeCredential(parsed, removeOriginalFields)\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return deepCopy({ ...normalizeJwtCredential(input.proof.jwt, removeOriginalFields), proof: input.proof })\n  } else {\n    // TODO: test that it accepts JWT payload, CredentialPayload, VerifiableCredential\n    // TODO: test that it correctly propagates proof, if any\n    return { proof: {}, ...normalizeJwtCredentialPayload(input, removeOriginalFields) }\n  }\n}\n\n/**\n * type used to signal a very loose input is accepted\n */\ntype DeepPartial<T> = T extends Record<string, unknown> ? { [K in keyof T]?: DeepPartial<T[K]> } : T\n\n/**\n * Transforms a W3C Credential payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input either a JWT payload or a CredentialPayloadInput\n */\nexport function transformCredentialInput(\n  input: Partial<CredentialPayload> | DeepPartial<JwtCredentialPayload>,\n  removeOriginalFields = true\n): JwtCredentialPayload {\n  if (Array.isArray(input.credentialSubject)) throw Error('credentialSubject of type array not supported')\n\n  const result: Partial<JwtCredentialPayload> = deepCopy({\n    vc: { ...input.vc },\n    ...input,\n  }) as Partial<JwtCredentialPayload>\n  result.vc = result.vc as NonNullable<typeof result.vc>\n\n  const credentialSubject = { ...input.credentialSubject, ...input.vc?.credentialSubject }\n  if (!input.sub) {\n    result.sub = input.credentialSubject?.id\n    if (removeOriginalFields) {\n      delete credentialSubject.id\n    }\n  }\n\n  const contextEntries = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vc?.['@context']),\n  ].filter(notEmpty)\n  result.vc['@context'] = [...new Set(contextEntries)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result['@context']\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vc?.type)].filter(notEmpty)\n  result.vc.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.type\n  }\n\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id\n    if (removeOriginalFields) {\n      delete result.id\n    }\n  }\n\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate)\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.issuanceDate\n      }\n    }\n  }\n\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate)\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.expirationDate\n      }\n    }\n  }\n\n  if (input.issuer && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.issuer === 'object') {\n      result.iss = input.issuer?.id\n      if (removeOriginalFields) {\n        delete result.issuer.id\n        if (Object.keys(result.issuer).length === 0) {\n          delete result.issuer\n        }\n      }\n    } else if (typeof input.issuer === 'string') {\n      result.iss = input.iss || '' + input.issuer\n      if (removeOriginalFields) {\n        delete result.issuer\n      }\n    } else {\n      // nop\n    }\n  }\n\n  result.vc.credentialSubject = credentialSubject\n  if (removeOriginalFields) {\n    delete result.credentialSubject\n  }\n\n  for (const prop of additionalPropNames) {\n    if (input[prop]) {\n      if (!result.vc[prop]) {\n        result.vc[prop] = input[prop]\n      }\n      if (removeOriginalFields) {\n        delete result[prop]\n      }\n    }\n  }\n\n  return result as JwtCredentialPayload\n}\n\nfunction normalizeJwtPresentationPayload(\n  input: DeepPartial<JwtPresentationPayload>,\n  removeOriginalFields = true\n): W3CPresentation {\n  const result: Partial<PresentationPayload> = deepCopy(input)\n\n  result.verifiableCredential = [\n    ...asArray(input.verifiableCredential),\n    ...asArray(input.vp?.verifiableCredential),\n  ].filter(notEmpty)\n  result.verifiableCredential = result.verifiableCredential.map((cred) => {\n    return normalizeCredential(cred, removeOriginalFields)\n  })\n  if (removeOriginalFields) {\n    delete result.vp?.verifiableCredential\n  }\n\n  if (input.iss && !input.holder) {\n    result.holder = input.iss\n    if (removeOriginalFields) {\n      delete result.iss\n    }\n  }\n\n  if (input.aud) {\n    result.verifier = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty)\n    result.verifier = [...new Set(result.verifier)]\n    if (removeOriginalFields) {\n      delete result.aud\n    }\n  }\n\n  if (input.jti && Object.getOwnPropertyNames(input).indexOf('id') === -1) {\n    result.id = input.id || input.jti\n    if (removeOriginalFields) {\n      delete result.jti\n    }\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty)\n  result.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.vp?.type\n  }\n\n  const contexts = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vp?.['@context']),\n  ].filter(notEmpty)\n  result['@context'] = [...new Set(contexts)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result.vp?.['@context']\n  }\n\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString()\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf\n      } else {\n        delete result.iat\n      }\n    }\n  }\n\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString()\n    if (removeOriginalFields) {\n      delete result.exp\n    }\n  }\n\n  if (result.vp && Object.keys(result.vp).length === 0) {\n    if (removeOriginalFields) {\n      delete result.vp\n    }\n  }\n\n  return result as W3CPresentation\n}\n\nfunction normalizeJwtPresentation(input: JWT, removeOriginalFields = true): Verifiable<W3CPresentation> {\n  let decoded\n  try {\n    decoded = decodeJWT(input)\n  } catch (e) {\n    throw new TypeError('unknown presentation format')\n  }\n  return {\n    ...normalizeJwtPresentationPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input,\n    },\n  }\n}\n\n/**\n * Normalizes a presentation payload into an unambiguous W3C Presentation data type\n * @param input either a JWT or JWT payload, or a VerifiablePresentation\n */\nexport function normalizePresentation(\n  input: Partial<PresentationPayload> | DeepPartial<JwtPresentationPayload> | JWT,\n  removeOriginalFields = true\n): Verifiable<W3CPresentation> {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtPresentation(input, removeOriginalFields)\n    } else {\n      let parsed: Record<string, unknown>\n      try {\n        parsed = JSON.parse(input)\n      } catch (e) {\n        throw new TypeError('unknown presentation format')\n      }\n      return normalizePresentation(parsed, removeOriginalFields)\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return { ...normalizeJwtPresentation(input.proof.jwt, removeOriginalFields), proof: input.proof }\n  } else {\n    // TODO: test that it accepts JWT payload, PresentationPayload, VerifiablePresentation\n    // TODO: test that it correctly propagates proof, if any\n    return { proof: {}, ...normalizeJwtPresentationPayload(input, removeOriginalFields) }\n  }\n}\n\n/**\n * Transforms a W3C Presentation payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input either a JWT payload or a CredentialPayloadInput\n */\nexport function transformPresentationInput(\n  input: Partial<PresentationPayload> | DeepPartial<JwtPresentationPayload>,\n  removeOriginalFields = true\n): JwtPresentationPayload {\n  const result: Partial<JwtPresentationPayload> = deepCopy({\n    vp: { ...input.vp },\n    ...input,\n  }) as Partial<JwtPresentationPayload>\n  result.vp = result.vp as NonNullable<typeof result.vp>\n\n  const contextEntries = [\n    ...asArray(input.context),\n    ...asArray(input['@context']),\n    ...asArray(input.vp?.['@context']),\n  ].filter(notEmpty)\n  result.vp['@context'] = [...new Set(contextEntries)]\n  if (removeOriginalFields) {\n    delete result.context\n    delete result['@context']\n  }\n\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty)\n  result.vp.type = [...new Set(types)]\n  if (removeOriginalFields) {\n    delete result.type\n  }\n\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id\n    if (removeOriginalFields) {\n      delete result.id\n    }\n  }\n\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate)\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.issuanceDate\n      }\n    }\n  }\n\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate)\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000)\n      if (removeOriginalFields) {\n        delete result.expirationDate\n      }\n    }\n  }\n\n  if (result.verifiableCredential || result.vp?.verifiableCredential) {\n    result.vp.verifiableCredential = [\n      ...asArray(result.verifiableCredential),\n      ...asArray(result.vp?.verifiableCredential),\n    ]\n      .filter(notEmpty)\n      .map((credential: VerifiableCredential) => {\n        if (typeof credential === 'object' && credential.proof?.jwt) {\n          return credential.proof.jwt\n        } else {\n          return credential\n        }\n      })\n  }\n\n  if (removeOriginalFields) {\n    delete result.verifiableCredential\n  }\n\n  if (input.holder && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.holder === 'string') {\n      result.iss = input.holder\n      if (removeOriginalFields) {\n        delete result.holder\n      }\n    } else {\n      // nop\n    }\n  }\n\n  if (input.verifier) {\n    const audience = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty)\n    result.aud = [...new Set(audience)]\n    if (removeOriginalFields) {\n      delete result.verifier\n    }\n  }\n\n  return result as JwtPresentationPayload\n}\n","import { DEFAULT_CONTEXT, DEFAULT_VC_TYPE, DEFAULT_VP_TYPE, JWT_FORMAT } from './types'\nimport { JwtCredentialSubject, DateType } from './types'\nimport { VerifiableCredential } from '.'\nimport { asArray } from './converters'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isDateObject(input: any): input is Date {\n  return input && !isNaN(input) && Object.prototype.toString.call(input) === '[object Date]'\n}\n\nexport function validateJwtFormat(value: VerifiableCredential): void {\n  if (typeof value === 'string' && !value.match(JWT_FORMAT)) {\n    throw new TypeError(`\"${value}\" is not a valid JWT format`)\n  }\n}\n\n// The main scenario we want to guard against is having a timestamp in milliseconds\n// instead of seconds (ex: from new Date().getTime()).\n// We will check the number of digits and assume that any number with 12 or more\n// digits is a millisecond timestamp.\n// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)\n// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)\n// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)\nexport function validateTimestamp(value: number | DateType): void {\n  if (typeof value === 'number') {\n    if (!(Number.isInteger(value) && value < 100000000000)) {\n      throw new TypeError(`\"${value}\" is not a unix timestamp in seconds`)\n    }\n  } else if (typeof value === 'string') {\n    validateTimestamp(Math.floor(new Date(value).valueOf() / 1000))\n  } else if (!isDateObject(value)) {\n    throw new TypeError(`\"${value}\" is not a valid time`)\n  }\n}\n\nexport function validateContext(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_CONTEXT) === -1) {\n    throw new TypeError(`@context is missing default context \"${DEFAULT_CONTEXT}\"`)\n  }\n}\n\nexport function validateVcType(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VC_TYPE}\"`)\n  }\n}\n\nexport function validateVpType(value: string | string[]): void {\n  const input = asArray(value)\n  if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {\n    throw new TypeError(`type is missing default \"${DEFAULT_VP_TYPE}\"`)\n  }\n}\n\nexport function validateCredentialSubject(value: JwtCredentialSubject): void {\n  if (Object.keys(value).length === 0) {\n    throw new TypeError('credentialSubject must not be empty')\n  }\n}\n","import { createJWT, verifyJWT } from 'did-jwt'\nimport { Resolvable } from 'did-resolver'\nimport * as validators from './validators'\nimport {\n  JwtCredentialPayload,\n  Issuer,\n  JwtPresentationPayload,\n  JWT,\n  VerifiablePresentation,\n  VerifiableCredential,\n  CredentialPayload,\n  PresentationPayload,\n  Verifiable,\n  W3CCredential,\n  W3CPresentation,\n  VerifiedCredential,\n  VerifiedPresentation,\n  VerifyPresentationOptions,\n  CreatePresentationOptions,\n  CreateCredentialOptions,\n  VerifyCredentialOptions,\n  JWT_ALG,\n} from './types'\nimport {\n  transformCredentialInput,\n  transformPresentationInput,\n  normalizeCredential,\n  normalizePresentation,\n  asArray,\n  notEmpty,\n} from './converters'\nexport {\n  Issuer,\n  CredentialPayload,\n  PresentationPayload,\n  JwtCredentialPayload,\n  JwtPresentationPayload,\n  VerifiableCredential,\n  VerifiablePresentation,\n  VerifiedCredential,\n  VerifiedPresentation,\n  Verifiable,\n  W3CCredential,\n  W3CPresentation,\n  transformCredentialInput,\n  transformPresentationInput,\n  normalizeCredential,\n  normalizePresentation,\n}\n\n/**\n * Creates a VerifiableCredential given a `CredentialPayload` or `JwtCredentialPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum spec\n * required spec.\n *\n * The `issuer` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload `CredentialPayload` or `JwtCredentialPayload`\n * @param issuer `Issuer` the DID, signer and algorithm that will sign the token\n * @return a `Promise` that resolves to the JWT encoded verifiable credential or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nexport async function createVerifiableCredentialJwt(\n  payload: JwtCredentialPayload | CredentialPayload,\n  issuer: Issuer,\n  options: CreateCredentialOptions = {}\n): Promise<JWT> {\n  const parsedPayload: JwtCredentialPayload = {\n    iat: undefined,\n    ...transformCredentialInput(payload, options.removeOriginalFields),\n  }\n  validateJwtCredentialPayload(parsedPayload)\n  return createJWT(\n    parsedPayload,\n    {\n      ...options,\n      issuer: issuer.did || parsedPayload.iss || '',\n      signer: issuer.signer,\n    },\n    {\n      ...options.header,\n      alg: issuer.alg || options.header?.alg || JWT_ALG,\n    }\n  )\n}\n\n/**\n * Creates a VerifiablePresentation JWT given a `PresentationPayload` or `JwtPresentationPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum spec\n * required spec.\n *\n * The `holder` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload `PresentationPayload` or `JwtPresentationPayload`\n * @param holder `Issuer` of the Presentation JWT (holder of the VC), signer and algorithm that will sign the token\n * @param options `CreatePresentationOptions` allows to pass additional values to the resulting JWT payload\n * @return a `Promise` that resolves to the JWT encoded verifiable presentation or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nexport async function createVerifiablePresentationJwt(\n  payload: JwtPresentationPayload | PresentationPayload,\n  holder: Issuer,\n  options: CreatePresentationOptions = {}\n): Promise<JWT> {\n  const parsedPayload: JwtPresentationPayload = {\n    iat: undefined,\n    ...transformPresentationInput(payload, options?.removeOriginalFields),\n  }\n\n  // add challenge to nonce\n  if (options.challenge && Object.getOwnPropertyNames(parsedPayload).indexOf('nonce') === -1) {\n    parsedPayload.nonce = options.challenge\n  }\n\n  // add domain to audience.\n  if (options.domain) {\n    const audience = [...asArray(options.domain), ...asArray(parsedPayload.aud)].filter(notEmpty)\n    parsedPayload.aud = [...new Set(audience)]\n  }\n\n  validateJwtPresentationPayload(parsedPayload)\n  return createJWT(\n    parsedPayload,\n    {\n      ...options,\n      issuer: holder.did || parsedPayload.iss || '',\n      signer: holder.signer,\n    },\n    {\n      ...options.header,\n      alg: holder.alg || options.header?.alg || JWT_ALG,\n    }\n  )\n}\n\nexport function validateJwtCredentialPayload(payload: JwtCredentialPayload): void {\n  validators.validateContext(payload.vc['@context'])\n  validators.validateVcType(payload.vc.type)\n  validators.validateCredentialSubject(payload.vc.credentialSubject)\n  if (payload.nbf) validators.validateTimestamp(payload.nbf)\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validateCredentialPayload(payload: CredentialPayload): void {\n  validators.validateContext(payload['@context'])\n  validators.validateVcType(payload.type)\n  validators.validateCredentialSubject(payload.credentialSubject)\n  if (payload.issuanceDate) validators.validateTimestamp(payload.issuanceDate)\n  if (payload.expirationDate) validators.validateTimestamp(payload.expirationDate)\n}\n\nexport function validateJwtPresentationPayload(payload: JwtPresentationPayload): void {\n  validators.validateContext(payload.vp['@context'])\n  validators.validateVpType(payload.vp.type)\n  // empty credential array is allowed\n  if (payload.vp.verifiableCredential && payload.vp.verifiableCredential.length >= 1) {\n    for (const vc of asArray(payload.vp.verifiableCredential)) {\n      if (typeof vc === 'string') {\n        validators.validateJwtFormat(vc)\n      } else {\n        validateCredentialPayload(vc)\n      }\n    }\n  }\n  if (payload.exp) validators.validateTimestamp(payload.exp)\n}\n\nexport function validatePresentationPayload(payload: PresentationPayload): void {\n  validators.validateContext(payload['@context'])\n  validators.validateVpType(payload.type)\n  // empty credential array is allowed\n  if (payload.verifiableCredential && payload.verifiableCredential.length >= 1) {\n    for (const vc of payload.verifiableCredential) {\n      if (typeof vc === 'string') {\n        validators.validateJwtFormat(vc)\n      } else {\n        validateCredentialPayload(vc)\n      }\n    }\n  }\n  if (payload.expirationDate) validators.validateTimestamp(payload.expirationDate)\n}\n\n/**\n * Verifies and validates a VerifiableCredential that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedCredential` or rejects with `TypeError` if the input is not\n * W3C compliant\n * @param vc the credential to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document of the JWT issuer\n */\nexport async function verifyCredential(\n  vc: JWT,\n  resolver: Resolvable,\n  options: VerifyCredentialOptions = {}\n): Promise<VerifiedCredential> {\n  const verified: Partial<VerifiedCredential> = await verifyJWT(vc, { resolver, ...options })\n  verified.verifiableCredential = normalizeCredential(verified.jwt as string, options?.removeOriginalFields)\n  validateCredentialPayload(verified.verifiableCredential)\n  return verified as VerifiedCredential\n}\n\n/**\n * Verifies that the given JwtPresentationPayload contains the appropriate options from VerifyPresentationOptions\n *\n * @param payload the JwtPresentationPayload to verify against\n * @param options the VerifyPresentationOptions that contain the optional values to verify.\n * @throws {Error} If VerifyPresentationOptions are not satisfied\n */\nexport function verifyPresentationPayloadOptions(\n  payload: JwtPresentationPayload,\n  options: VerifyPresentationOptions\n): void {\n  if (options.challenge && options.challenge !== payload.nonce) {\n    throw new Error(`Presentation does not contain the mandatory challenge (JWT: nonce) for : ${options.challenge}`)\n  }\n\n  if (options.domain) {\n    // aud might be array\n    let matchedAudience\n    if (payload.aud) {\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      matchedAudience = audArray.find((item) => options.domain === item)\n    }\n\n    if (typeof matchedAudience === 'undefined') {\n      throw new Error(`Presentation does not contain the mandatory domain (JWT: aud) for : ${options.domain}`)\n    }\n  }\n}\n\n/**\n * Verifies and validates a VerifiablePresentation that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedPresentation` or rejects with `TypeError` if the input is\n * not W3C compliant or the VerifyPresentationOptions are not satisfied.\n * @param presentation the presentation to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver a configured `Resolver` or an implementation of `Resolvable` that can provide the DID document of the JWT issuer (presentation holder)\n * @param options optional verification options that need to be satisfied\n */\nexport async function verifyPresentation(\n  presentation: JWT,\n  resolver: Resolvable,\n  options: VerifyPresentationOptions = {}\n): Promise<VerifiedPresentation> {\n  const verified: Partial<VerifiedPresentation> = await verifyJWT(presentation, { resolver, ...options })\n  verifyPresentationPayloadOptions(verified.payload as JwtPresentationPayload, options)\n  verified.verifiablePresentation = normalizePresentation(verified.jwt as string, options?.removeOriginalFields)\n  validatePresentationPayload(verified.verifiablePresentation)\n  return verified as VerifiedPresentation\n}\n"],"names":["JWT_ALG","JWT_FORMAT","DEFAULT_CONTEXT","DEFAULT_VC_TYPE","DEFAULT_VP_TYPE","DEFAULT_JWT_PROOF_TYPE","additionalPropNames","asArray","arg","Array","isArray","deepCopy","source","map","item","Date","getTime","Object","getOwnPropertyNames","reduce","o","prop","defineProperty","getOwnPropertyDescriptor","create","getPrototypeOf","notEmpty","value","normalizeJwtCredentialPayload","input","removeOriginalFields","result","payload","sub","iss","claim","iat","nbf","vc","rest","type","credentialSubject","issVc","attestationToVcFormat","_input$vc","_input$credentialSubj","id","issuer","obj","keys","forEach","key","undefined","cleanUndefined","_input$issuer","jti","types","_result$vc2","filter","Set","contextArray","context","_input$vc2","issuanceDate","toISOString","expirationDate","exp","length","normalizeJwtCredential","decoded","decodeJWT","e","TypeError","proof","jwt","normalizeCredential","test","parsed","JSON","parse","_input$proof","transformCredentialInput","Error","_input$vc3","_input$credentialSubj2","contextEntries","_input$vc4","_input$vc5","indexOf","converted","isNaN","Math","floor","_input$issuer2","normalizeJwtPresentationPayload","verifiableCredential","vp","_input$vp","cred","holder","aud","verifier","_input$vp2","contexts","_input$vp3","normalizeJwtPresentation","normalizePresentation","_input$proof2","transformPresentationInput","_input$vp4","_input$vp5","_result$vp4","_result$vp5","credential","_credential$proof","audience","validateJwtFormat","match","validateTimestamp","Number","isInteger","valueOf","prototype","toString","call","validateContext","validateVcType","validateVpType","validateCredentialSubject","validateJwtCredentialPayload","validators","validateCredentialPayload","validateJwtPresentationPayload","validatePresentationPayload","verifyPresentationPayloadOptions","options","challenge","nonce","domain","matchedAudience","find","parsedPayload","createJWT","did","signer","header","alg","_options$header","_options$header2","resolver","verifyJWT","verified","presentation","verifiablePresentation"],"mappings":"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"}