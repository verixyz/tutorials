{"version":3,"file":"resolver.modern.js","sources":["../src/resolver.ts"],"sourcesContent":["import fetch from 'cross-fetch'\nimport { DIDDocument, DIDResolutionResult, DIDResolver, ParsedDID } from 'did-resolver'\n\nconst DOC_PATH = '/.well-known/did.json'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function get(url: string): Promise<any> {\n  const res = await fetch(url, { mode: 'cors' })\n  if (res.status >= 400) {\n    throw new Error(`Bad response ${res.statusText}`)\n  }\n  return res.json()\n}\n\nexport function getResolver(): Record<string, DIDResolver> {\n  async function resolve(did: string, parsed: ParsedDID): Promise<DIDResolutionResult> {\n    let err = null\n    let path = decodeURIComponent(parsed.id) + DOC_PATH\n    const id = parsed.id.split(':')\n    if (id.length > 1) {\n      path = id.map(decodeURIComponent).join('/') + '/did.json'\n    }\n\n    const url = `https://${path}`\n\n    const didDocumentMetadata = {}\n    let didDocument: DIDDocument | null = null\n\n    do {\n      try {\n        didDocument = await get(url)\n      } catch (error) {\n        err = `resolver_error: DID must resolve to a valid https URL containing a JSON document: ${error}`\n        break\n      }\n\n      // TODO: this excludes the use of query params\n      const docIdMatchesDid = didDocument?.id === did\n      if (!docIdMatchesDid) {\n        err = 'resolver_error: DID document id does not match requested did'\n        // break // uncomment this when adding more checks\n      }\n      // eslint-disable-next-line no-constant-condition\n    } while (false)\n\n    const contentType =\n      typeof didDocument?.['@context'] !== 'undefined' ? 'application/did+ld+json' : 'application/did+json'\n\n    if (err) {\n      return {\n        didDocument,\n        didDocumentMetadata,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: err,\n        },\n      }\n    } else {\n      return {\n        didDocument,\n        didDocumentMetadata,\n        didResolutionMetadata: { contentType },\n      }\n    }\n  }\n\n  return { web: resolve }\n}\n"],"names":["DOC_PATH","get","url","res","fetch","mode","status","Error","statusText","json","getResolver","resolve","did","parsed","err","path","decodeURIComponent","id","split","length","map","join","didDocumentMetadata","didDocument","error","docIdMatchesDid","contentType","didResolutionMetadata","message","web"],"mappings":";;AAGA,MAAMA,QAAQ,GAAG,uBAAjB;;AAGA,eAAeC,GAAf,CAAmBC,GAAnB;AACE,QAAMC,GAAG,GAAG,MAAMC,KAAK,CAACF,GAAD,EAAM;AAAEG,IAAAA,IAAI,EAAE;AAAR,GAAN,CAAvB;;AACA,MAAIF,GAAG,CAACG,MAAJ,IAAc,GAAlB,EAAuB;AACrB,UAAM,IAAIC,KAAJ,iBAA0BJ,GAAG,CAACK,YAA9B,CAAN;AACD;;AACD,SAAOL,GAAG,CAACM,IAAJ,EAAP;AACD;;SAEeC;AACd,iBAAeC,OAAf,CAAuBC,GAAvB,EAAoCC,MAApC;;;AACE,QAAIC,GAAG,GAAG,IAAV;AACA,QAAIC,IAAI,GAAGC,kBAAkB,CAACH,MAAM,CAACI,EAAR,CAAlB,GAAgCjB,QAA3C;AACA,UAAMiB,EAAE,GAAGJ,MAAM,CAACI,EAAP,CAAUC,KAAV,CAAgB,GAAhB,CAAX;;AACA,QAAID,EAAE,CAACE,MAAH,GAAY,CAAhB,EAAmB;AACjBJ,MAAAA,IAAI,GAAGE,EAAE,CAACG,GAAH,CAAOJ,kBAAP,EAA2BK,IAA3B,CAAgC,GAAhC,IAAuC,WAA9C;AACD;;AAED,UAAMnB,GAAG,cAAca,MAAvB;AAEA,UAAMO,mBAAmB,GAAG,EAA5B;AACA,QAAIC,WAAW,GAAuB,IAAtC;;AAEA,OAAG;AAAA;;AACD,UAAI;AACFA,QAAAA,WAAW,GAAG,MAAMtB,GAAG,CAACC,GAAD,CAAvB;AACD,OAFD,CAEE,OAAOsB,KAAP,EAAc;AACdV,QAAAA,GAAG,wFAAwFU,OAA3F;AACA;AACD,OANA;;;AASD,YAAMC,eAAe,GAAG,iBAAAF,WAAW,SAAX,yBAAaN,EAAb,MAAoBL,GAA5C;;AACA,UAAI,CAACa,eAAL,EAAsB;AACpBX,QAAAA,GAAG,GAAG,8DAAN,CADoB;AAGrB,OAbA;;AAeF,KAfD,QAeS,KAfT;;AAiBA,UAAMY,WAAW,GACf,yBAAOH,WAAP,qBAAO,cAAc,UAAd,CAAP,MAAqC,WAArC,GAAmD,yBAAnD,GAA+E,sBADjF;;AAGA,QAAIT,GAAJ,EAAS;AACP,aAAO;AACLS,QAAAA,WADK;AAELD,QAAAA,mBAFK;AAGLK,QAAAA,qBAAqB,EAAE;AACrBH,UAAAA,KAAK,EAAE,UADc;AAErBI,UAAAA,OAAO,EAAEd;AAFY;AAHlB,OAAP;AAQD,KATD,MASO;AACL,aAAO;AACLS,QAAAA,WADK;AAELD,QAAAA,mBAFK;AAGLK,QAAAA,qBAAqB,EAAE;AAAED,UAAAA;AAAF;AAHlB,OAAP;AAKD;AACF;;AAED,SAAO;AAAEG,IAAAA,GAAG,EAAElB;AAAP,GAAP;AACD;;;;"}